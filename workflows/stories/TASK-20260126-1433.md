# Story: Fix Memory Estimation for Model Loading by Adding Native getAvailableMemory() API

## Metadata
- **Task ID**: TASK-20260126-1433
- **Issue**: Action Tracker Item - "Memory Estimation for Model Loading"
- **Source**: action-tracker (P2 priority)
- **Complexity**: standard
- **Native Changes**: YES
- **Created**: 2026-01-26
- **Status**: draft

## Environment
- **Worktree**: `/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260126-1433`
- **Branch**: `feature/TASK-20260126-1433`
- **Base**: `main`

---

## Progress Tracking

### Current Phase
**Phase 1**: `[X] Planning → [X] Approved → [X] Implementing → [X] Testing → [X] Reviewing → [X] PR Created`
**Phase 2**: `[X] Planning → [X] Approved → [X] Implementing → [X] Testing → [ ] Reviewing → [ ] PR Updated`

### Checkpoints (Updated by Agents)

| Checkpoint | Status | Agent | Commit | Notes |
|------------|--------|-------|--------|-------|
| Worktree created | DONE | orchestrator | - | |
| Story approved | DONE | human | - | |
| Step 1 complete | DONE | implementer | a4e3e41 | Android getAvailableMemory() |
| Step 2 complete | DONE | implementer | 85f65e4 | iOS getAvailableMemory() |
| Step 3 complete | DONE | implementer | 044dd9a | Update TurboModule spec |
| Step 4 complete | DONE | implementer | 3067109 | Update useMemoryCheck logic |
| Step 5 complete | DONE | implementer | d249574 | Update mocks |
| iOS header fix | DONE | implementer | 5016e1b | Fixed os/proc.h import |
| Tests verified | DONE | implementer | - | Existing tests pass |
| Platform builds | DONE | implementer | - | iOS and Android succeed |
| Tests written | DONE | tester | 355a850 | 3 new tests added |
| Review passed | DONE | reviewer | - | All checks pass |
| PR created | DONE | reviewer | - | PR #544 |
| **Phase 2** | | | | |
| Phase 2 planning | DONE | human | - | Hybrid memory tracking approach |
| Phase 2 approved | DONE | human | - | |
| Step 8: Add observable | DONE | implementer | df836c9 | loadedModelMemoryUsage added |
| Step 9: Measure delta | DONE | implementer | d03d4f5 | Memory before/after tracking |
| Step 10: Clear on release | DONE | implementer | 65176a4 | Clear in finally block |
| Step 11: Effective available | DONE | implementer | ed04082 | Calculate effective memory |
| Prettier fix | DONE | implementer | b46f15b | Formatting |
| Phase 2 tests | DONE | implementer | 1ad99e6 | 3 new tests added |
| Phase 2 review | PENDING | reviewer | - | |
| PR updated | PENDING | reviewer | - | |

### Last Agent Handoff
```yaml
from_agent: implementer
to_agent: reviewer
timestamp: 2026-01-26T16:30:00Z
status: "Phase 2 implementation complete, ready for review"
completed:
  - Phase 1: Native getAvailableMemory() API (commits a4e3e41-5016e1b)
  - Phase 1: Tests and PR (commits 355a850, PR #544)
  - Phase 2: Step 8 - Added loadedModelMemoryUsage observable (commit df836c9)
  - Phase 2: Step 9 - Measure memory delta during load (commit d03d4f5)
  - Phase 2: Step 10 - Clear on context release (commit 65176a4)
  - Phase 2: Step 11 - Calculate effective available (commit ed04082)
  - Phase 2: Prettier fix (commit b46f15b)
  - Phase 2: Tests - 3 new tests for effective available (commit 1ad99e6)
  - All tests pass: 1361 tests, 9/9 in useMemoryCheck.test.ts
  - Lint: PASS (only pre-existing warnings)
  - TypeCheck: PASS
next_steps:
  - Review Phase 2 changes
  - Verify logic is correct
  - Update PR #544 with Phase 2 commits
  - Run platform builds (no native changes, but good to verify)
blockers: []
context_for_next_agent: |
  Phase 2 implementation is complete and tested.

  **What Phase 2 Does:**
  - Tracks actual memory consumed by loaded model (before/after measurement)
  - When checking if new model fits, adds back current model memory
  - Fallback to estimate if actual measurement unavailable
  - This fixes UX issue where users see "not enough memory" when switching models

  **Example:**
  - 5GB total memory, 3GB available, 2GB model loaded
  - Without Phase 2: Can't load 4GB model (only 3GB available)
  - With Phase 2: Can load 4GB model (3GB + 2GB released = 5GB effective)

  **Testing:**
  - All 3 scenarios tested (actual memory, estimate, no model)
  - Mock store updated with new properties
  - Debug logging added for validation

  **No Native Changes:**
  - Phase 2 is pure JavaScript/TypeScript
  - No pod install or platform builds needed
  - Safe to merge after code review

  See Phase 2 Implementation Report in story for full details.
```

---

## Context (For Recovery After Context Reset)

> **If you're an agent resuming work on this story:**
> 1. Read the "Progress Tracking" section above
> 2. Check `git log` in the worktree for commits
> 3. Read the "Last Agent Handoff" section
> 4. Continue from the next incomplete checkpoint

### Background

PocketPal AI currently uses a heuristic formula to estimate available memory for model loading:
```typescript
const availableMemory = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
```

This formula was created based on limited device testing and overestimates available memory on high-end devices. For example:
- **Pixel 9 (12GB RAM)**: Formula estimates 7.7GB available, but actual is 6.3GB (22% overestimate)
- **OnePlus 6 (8GB RAM)**: Formula estimates 5.2GB available, actual is ~4.8GB (8% overestimate)

This causes Out-Of-Memory (OOM) crashes, which account for ~10% of total app crashes (18 OOM crashes reported with signatures like `lm_ggml_gallocr_alloc_graph`, `lm_ggml_abort`).

User feedback validates this: "Unsuitable Model Size Recommendations For Device" mentioned 3x in recent feedback.

The solution is to query the OS directly for **actual available memory** instead of estimating.

### Current State

**File**: `src/hooks/useMemoryCheck.ts`
- Imports `DeviceInfo.getTotalMemory()` from `react-native-device-info`
- Calculates `availableMemory` using heuristic: `Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2)`
- Exports `hasEnoughMemory(modelSize, isMultimodal)` function
- Used by `ModelStore.initContext()` to check if model can load (line 1031 in ModelStore.ts)

**File**: `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt`
- TurboModule that provides `getCPUInfo()`, `getGPUInfo()`, `getChipset()`
- Does NOT currently provide memory information
- Follows React Native TurboModule pattern (extends `NativeHardwareInfoSpec`)

**File**: `ios/PocketPal/HardwareInfoModule.mm`
- Objective-C++ module that provides `getCPUInfo()`, `getGPUInfo()`
- Does NOT currently provide memory information
- Uses `RCT_EXPORT_METHOD` macros

**File**: `src/specs/NativeHardwareInfo.ts`
- TurboModule spec defining the interface for native modules
- Exports `CPUInfo`, `GPUInfo` interfaces
- Does NOT include memory methods

**File**: `jest/setup.ts` (lines 56-75)
- Mocks `NativeHardwareInfo` globally for tests
- Returns mock data for `getCPUInfo()` and `getGPUInfo()`

**File**: `__mocks__/external/react-native-device-info.js`
- Mocks `DeviceInfo.getTotalMemory()` and `getUsedMemory()` 
- Uses fixtures from `jest/fixtures/device-info.ts`

### Target State

After this change:
1. `NativeHardwareInfo` TurboModule exposes `getAvailableMemory(): Promise<number>` method
2. Android implementation reads `/proc/meminfo` MemAvailable field
3. iOS implementation uses `os_proc_available_memory()` API
4. `useMemoryCheck.ts` uses native available memory with 10% safety margin + fallback to heuristic
5. Tests updated to mock `getAvailableMemory()` 
6. Platform builds succeed (pod install, iOS/Android release builds)

---

## Requirements

### Functional
1. [MUST] Android `HardwareInfoModule.kt` implements `getAvailableMemory()` using `ActivityManager.getMemoryInfo()` (official Android API)
2. [MUST] iOS `HardwareInfoModule.mm` implements `getAvailableMemory()` using `os_proc_available_memory()` API
3. [MUST] `NativeHardwareInfo.ts` TurboModule spec includes `getAvailableMemory(): Promise<number>` method
4. [MUST] `useMemoryCheck.ts` calls native `getAvailableMemory()` instead of calculating heuristic
5. [MUST] Apply 10% safety margin to available memory (return `availableMemory * 0.9`)
6. [MUST] Fallback to current heuristic if native API fails (for robustness)
7. [MUST] Update test mocks in `jest/setup.ts` and `__mocks__/external/react-native-device-info.js`
8. [SHOULD] Log actual vs estimated memory in debug builds for validation

### Non-Functional
- **Performance**: Native call should be fast (<10ms), cached if called frequently
- **Compatibility**: Must work on Android API 21+ and iOS 14+
- **Reliability**: Must not crash if API unavailable (graceful fallback)
- **Testing**: Must maintain 60%+ test coverage

### Platform Verification (NATIVE_CHANGES=YES)
- [ ] `pod install` succeeds
- [ ] iOS Release build succeeds
- [ ] Android Release build succeeds
- [ ] `ios/Podfile.lock` changes committed (if any)

---

## Acceptance Criteria

- [ ] Android uses `ActivityManager.getMemoryInfo()` and returns `availMem` in bytes
- [ ] iOS uses `os_proc_available_memory()` and returns bytes
- [ ] `getAvailableMemory()` returns actual available memory in bytes
- [ ] `useMemoryCheck.ts` applies 10% safety margin
- [ ] If native call fails, falls back to heuristic (no crash)
- [ ] All existing tests pass
- [ ] New tests added for `getAvailableMemory()` 
- [ ] Coverage >= 60%
- [ ] Platform builds succeed (iOS + Android Release)
- [ ] Manual testing on real device shows accurate memory estimation

---

## Phase 2: Track Loaded Model Memory (Enhancement)

### Problem Identified Post-Implementation

The Phase 1 implementation queries current available memory, but this creates an issue when a model is already loaded:

| Scenario | Available Memory | Loaded Model | Check for New 4GB Model |
|----------|------------------|--------------|-------------------------|
| No model | 5GB | - | ✅ Pass (5GB > 4GB needed) |
| 2GB model loaded | 3GB | Using ~2GB | ❌ Fail - but would fit if current released! |

**Issue**: User sees "not enough memory" warning when switching models, even though the new model would fit after releasing the current one.

### Solution: Hybrid Memory Tracking (Approach 4)

1. **Track actual memory delta** when loading a model (before/after measurement)
2. **Fallback to estimate** if delta unavailable (app restart, first check)
3. **Add back loaded model memory** when checking if new model fits

### Phase 2 Requirements

#### Functional
1. [MUST] Track actual memory consumption when model loads (before - after)
2. [MUST] Store `loadedModelMemoryUsage` in ModelStore as observable
3. [MUST] Clear `loadedModelMemoryUsage` when model is released
4. [MUST] In `hasEnoughMemory()`, calculate effective available as: `nativeAvailable + loadedModelMemoryUsage`
5. [MUST] Fallback to `memoryRequirementEstimate()` of current model if actual delta unavailable
6. [SHOULD] Persist memory usage to handle app restart (optional, estimate fallback is acceptable)

#### Non-Functional
- Must not add noticeable latency to model loading
- Memory tracking should work even if interrupted (fallback to estimate)

### Phase 2 Acceptance Criteria

- [ ] ModelStore has `loadedModelMemoryUsage: number | undefined` observable
- [ ] Memory delta measured in `initContext()` (before load - after load)
- [ ] `loadedModelMemoryUsage` cleared in `releaseContext()`
- [ ] `hasEnoughMemory()` adds back current model memory to available
- [ ] Fallback to estimate when `loadedModelMemoryUsage` is undefined
- [ ] User can switch from 2GB model to 4GB model when 5GB total available
- [ ] Tests verify effective available calculation
- [ ] Tests verify fallback behavior

### Phase 2 Affected Files

| File | Action | Reason |
|------|--------|--------|
| `src/store/ModelStore.ts` | MODIFY | Add loadedModelMemoryUsage tracking |
| `src/hooks/useMemoryCheck.ts` | MODIFY | Add effective available calculation |
| `src/hooks/__tests__/useMemoryCheck.test.ts` | MODIFY | Test effective available + fallback |

---

## Affected Files

| File | Action | Reason | Status |
|------|--------|--------|--------|
| `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt` | MODIFY | Add getAvailableMemory() method | PENDING |
| `ios/PocketPal/HardwareInfoModule.mm` | MODIFY | Add getAvailableMemory() method | PENDING |
| `src/specs/NativeHardwareInfo.ts` | MODIFY | Add getAvailableMemory() to Spec interface | PENDING |
| `src/hooks/useMemoryCheck.ts` | MODIFY | Use native API instead of heuristic | PENDING |
| `src/hooks/__tests__/useMemoryCheck.test.ts` | MODIFY | Update tests to verify native API usage | PENDING |
| `jest/setup.ts` | MODIFY | Add getAvailableMemory() to NativeHardwareInfo mock | PENDING |
| `__mocks__/external/react-native-device-info.js` | MODIFY | (Optional) Add getAvailableMemory() if needed | PENDING |
| `jest/fixtures/device-info.ts` | MODIFY | Add availableMemory fixture data | PENDING |
| `ios/Podfile.lock` | UPDATE | May change after pod install | PENDING |

---

## Implementation Plan

### Step 1: Add getAvailableMemory() to Android Native Module
**Files**: `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add import for `android.app.ActivityManager` and `android.content.Context`
- [ ] Add `getAvailableMemory(promise: Promise)` method to `HardwareInfoModule` class
- [ ] Override method from `NativeHardwareInfoSpec` (will be added in Step 3)
- [ ] Use `ActivityManager.getMemoryInfo()` to get available memory (official Android API)
- [ ] Resolve promise with `memInfo.availMem` as Double (already in bytes)
- [ ] Handle errors gracefully (reject promise with error message)

**Why ActivityManager instead of /proc/meminfo:**
- Official Android API - works reliably across all devices and Android versions
- No SELinux permission issues on newer Android or OEM ROMs
- Abstracts away kernel differences (MemAvailable wasn't added until Linux 3.14)
- Provides bonus `lowMemory` flag for free
- Same underlying data: `availMem` equals `MemFree + Cached` from /proc/meminfo

**Pattern Reference**: See `HardwareInfoModule.kt:133-197` (getCPUInfo method) for promise pattern

**Code Guidance**:
```kotlin
// Add imports at top of file
import android.app.ActivityManager
import android.content.Context

// Add method in HardwareInfoModule class
override fun getAvailableMemory(promise: Promise) {
  try {
    val activityManager = reactApplicationContext
      .getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
    val memInfo = ActivityManager.MemoryInfo()
    activityManager.getMemoryInfo(memInfo)

    // availMem is already in bytes
    promise.resolve(memInfo.availMem.toDouble())
  } catch (e: Exception) {
    promise.reject("ERROR", e.message)
  }
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn lint
yarn typecheck
```

### Step 2: Add getAvailableMemory() to iOS Native Module
**Files**: `ios/PocketPal/HardwareInfoModule.mm`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Import `<mach/mach.h>` and `<sys/sysctl.h>` headers at top
- [ ] Add `RCT_EXPORT_METHOD(getAvailableMemory:...)` 
- [ ] Call `os_proc_available_memory()` to get available memory in bytes
- [ ] Resolve promise with bytes as NSNumber
- [ ] Handle errors gracefully (catch exceptions, reject promise)

**Pattern Reference**: See `HardwareInfoModule.mm:12-26` (getCPUInfo method) for promise pattern

**Code Guidance**:
```objective-c
#import <React/RCTBridgeModule.h>
#import <UIKit/UIKit.h>
#import <Metal/Metal.h>
#import <mach/mach.h>
#import <sys/sysctl.h>

// ... existing code ...

RCT_EXPORT_METHOD(getAvailableMemory:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
  @try {
    // Get available memory using os_proc_available_memory()
    uint64_t availableMemory = os_proc_available_memory();
    
    if (availableMemory == 0) {
      reject(@"error_getting_available_memory", @"Could not retrieve available memory", nil);
      return;
    }
    
    resolve(@(availableMemory));
  } @catch (NSException *exception) {
    reject(@"error_getting_available_memory", @"Could not retrieve available memory", nil);
  }
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn lint
yarn typecheck
```

### Step 3: Update TurboModule Spec
**Files**: `src/specs/NativeHardwareInfo.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add `getAvailableMemory(): Promise<number>` to `Spec` interface (line 33-37)
- [ ] Add JSDoc comment explaining return value (bytes)

**Pattern Reference**: See `NativeHardwareInfo.ts:34-36` (getCPUInfo, getGPUInfo methods)

**Code Guidance**:
```typescript
export interface Spec extends TurboModule {
  getCPUInfo(): Promise<CPUInfo>;
  getGPUInfo(): Promise<GPUInfo>;
  getChipset?(): Promise<string>; // Android only
  /**
   * Get available memory in bytes from the operating system.
   * - Android: Reads MemAvailable from /proc/meminfo
   * - iOS: Uses os_proc_available_memory()
   * @returns Promise<number> Available memory in bytes
   */
  getAvailableMemory(): Promise<number>;
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
```

### Step 4: Update useMemoryCheck to Use Native API
**Files**: `src/hooks/useMemoryCheck.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Import `NativeHardwareInfo` at top: `import NativeHardwareInfo from '../specs/NativeHardwareInfo';`
- [ ] Replace `hasEnoughMemory()` implementation (lines 20-30):
  - Call `NativeHardwareInfo.getAvailableMemory()` to get actual available memory
  - Apply 10% safety margin: `actualAvailable * 0.9`
  - If native call fails, fallback to current heuristic formula
  - Add console.log in debug mode to compare actual vs heuristic
- [ ] Keep `memoryRequirementEstimate()` unchanged (model requirement calculation is correct)

**Pattern Reference**: See `src/utils/deviceCapabilities.ts:85-88` for calling NativeHardwareInfo pattern

**Code Guidance**:
```typescript
export const hasEnoughMemory = async (
  modelSize: number,
  isMultimodal = false,
): Promise<boolean> => {
  let availableMemoryGB: number;

  try {
    // Try native API first (actual available memory from OS)
    const availableBytes = await NativeHardwareInfo.getAvailableMemory();
    // Apply 10% safety margin
    const safeAvailableBytes = availableBytes * 0.9;
    availableMemoryGB = safeAvailableBytes / 1000 / 1000 / 1000;
    
    // Debug logging to validate accuracy
    if (__DEV__) {
      const totalMemory = await DeviceInfo.getTotalMemory();
      const totalMemoryGB = totalMemory / 1000 / 1000 / 1000;
      const heuristicAvailable = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
      console.log('[MemoryCheck] Actual available:', availableMemoryGB.toFixed(2), 'GB');
      console.log('[MemoryCheck] Heuristic estimate:', heuristicAvailable.toFixed(2), 'GB');
      console.log('[MemoryCheck] Difference:', ((heuristicAvailable - availableMemoryGB) / availableMemoryGB * 100).toFixed(1), '%');
    }
  } catch (error) {
    // Fallback to heuristic if native API fails
    console.warn('[MemoryCheck] Native API failed, using heuristic:', error);
    const totalMemory = await DeviceInfo.getTotalMemory();
    const totalMemoryGB = totalMemory / 1000 / 1000 / 1000;
    availableMemoryGB = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
  }

  const memoryRequirement = memoryRequirementEstimate(modelSize, isMultimodal);
  return memoryRequirement <= availableMemoryGB;
};
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn lint
yarn typecheck
yarn test --findRelatedTests src/hooks/useMemoryCheck.ts
```

### Step 5: Update Test Mocks
**Files**: `jest/setup.ts`, `jest/fixtures/device-info.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] In `jest/setup.ts` (lines 56-75), add `getAvailableMemory` to NativeHardwareInfo mock
- [ ] Mock should return realistic value: ~2.5GB available for 4GB total device
- [ ] In `jest/fixtures/device-info.ts`, add `availableMemory: 2.5 * 1000 ** 3` to fixture
- [ ] Ensure mock is consistent with totalMemory (availableMemory < totalMemory)

**Pattern Reference**: See `jest/setup.ts:60-74` for existing NativeHardwareInfo mock structure

**Code Guidance**:
```typescript
// jest/setup.ts (add to existing mock around line 74)
jest.mock('../src/specs/NativeHardwareInfo', () => ({
  __esModule: true,
  default: {
    getCPUInfo: jest.fn(() => Promise.resolve({cores: 4})),
    getGPUInfo: jest.fn(() =>
      Promise.resolve({
        renderer: 'Mock GPU',
        vendor: 'Mock Vendor',
        version: 'Mock Version',
        hasAdreno: false,
        hasMali: false,
        hasPowerVR: false,
        supportsOpenCL: false,
        gpuType: 'Mock GPU',
      }),
    ),
    getChipset: jest.fn(() => Promise.resolve('Mock Chipset')),
    getAvailableMemory: jest.fn(() => Promise.resolve(2.5 * 1000 * 1000 * 1000)), // 2.5GB
  },
}));
```

```typescript
// jest/fixtures/device-info.ts (add to deviceInfo object)
export const deviceInfo = {
  freeDiskStorage: 8 * 1000 ** 3,
  totalMemory: 4 * 1000 ** 3,
  usedMemory: 2 * 1000 ** 3,
  availableMemory: 2.5 * 1000 ** 3, // More accurate than totalMemory - usedMemory
  version: '1.0.0',
  buildNumber: '1',
};
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn test
```

### Step 6: Update useMemoryCheck Tests
**Files**: `src/hooks/__tests__/useMemoryCheck.test.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add test: "should use native getAvailableMemory() API"
- [ ] Add test: "should fallback to heuristic if native API fails"
- [ ] Add test: "should apply 10% safety margin to native available memory"
- [ ] Verify existing tests still pass with new implementation

**Pattern Reference**: See `useMemoryCheck.test.ts:58-92` for error handling test pattern

**Code Guidance**:
```typescript
import NativeHardwareInfo from '../../specs/NativeHardwareInfo';

// Add after existing tests
it('should use native getAvailableMemory() API', async () => {
  // Mock native API to return 3GB available
  (NativeHardwareInfo.getAvailableMemory as jest.Mock).mockResolvedValue(
    3 * 1000 * 1000 * 1000
  );

  const {result, waitForNextUpdate} = renderHook(() =>
    useMemoryCheck(localModel.size),
  );

  try {
    await waitForNextUpdate();
  } catch {
    // Ignoring timeout
  }

  // Should pass because model is small and 3GB * 0.9 = 2.7GB available
  expect(result.current).toEqual({
    memoryWarning: '',
    shortMemoryWarning: '',
    multimodalWarning: '',
  });
  
  expect(NativeHardwareInfo.getAvailableMemory).toHaveBeenCalled();
});

it('should fallback to heuristic if native API fails', async () => {
  (NativeHardwareInfo.getAvailableMemory as jest.Mock).mockRejectedValue(
    new Error('Native API error')
  );

  const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const {result, waitForNextUpdate} = renderHook(() =>
    useMemoryCheck(localModel.size),
  );

  try {
    await waitForNextUpdate();
  } catch {
    // Ignoring timeout
  }

  // Should still work with fallback
  expect(result.current.memoryWarning).toBe('');
  expect(consoleWarnSpy).toHaveBeenCalledWith(
    expect.stringContaining('Native API failed'),
    expect.any(Error)
  );

  consoleWarnSpy.mockRestore();
});

it('should apply 10% safety margin to available memory', async () => {
  // Mock exactly enough memory (3.5GB available)
  // Model needs ~3.2GB (after margin it's 3.15GB available)
  const modelSize = 3.5 * 1000 * 1000 * 1000; // 3.5GB model
  (NativeHardwareInfo.getAvailableMemory as jest.Mock).mockResolvedValue(
    3.5 * 1000 * 1000 * 1000
  );

  const {result, waitForNextUpdate} = renderHook(() =>
    useMemoryCheck(modelSize),
  );

  try {
    await waitForNextUpdate();
  } catch {
    // Ignoring timeout
  }

  // After 10% margin, 3.5GB becomes 3.15GB available
  // Model requirement: 0.43 + (0.92 * 3.5) = 3.65GB
  // Should show warning because 3.65GB > 3.15GB
  expect(result.current.memoryWarning).toBe(l10n.en.memory.warning);
});
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn test src/hooks/__tests__/useMemoryCheck.test.ts
```

### Step 7: Platform Verification (NATIVE_CHANGES=YES)
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Run `cd ios && pod install && cd ..`
- [ ] Commit Podfile.lock changes (if any)
- [ ] Run `yarn ios --configuration Release` (verify iOS build succeeds)
- [ ] Run `yarn android --variant=release` (verify Android build succeeds)
- [ ] Test on real device (optional but recommended for validation)

**Verification**:
```bash
cd "${WORKTREE_PATH}"

# iOS
cd ios && pod install && cd ..
yarn ios --configuration Release

# Android
yarn android --variant=release

# Manual test on device
# 1. Open app on physical device
# 2. Check logs for "[MemoryCheck] Actual available" debug output
# 3. Try loading a model near memory limit
# 4. Verify no OOM crash
```

---

## Test Requirements

### Unit Tests
| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| Should use native getAvailableMemory() API | `useMemoryCheck.test.ts` | MUST | PENDING |
| Should fallback to heuristic if native API fails | `useMemoryCheck.test.ts` | MUST | PENDING |
| Should apply 10% safety margin | `useMemoryCheck.test.ts` | MUST | PENDING |
| Existing: returns no warning when safe | `useMemoryCheck.test.ts` | MUST | PENDING |
| Existing: returns warning when unsafe | `useMemoryCheck.test.ts` | MUST | PENDING |
| Existing: handles errors gracefully | `useMemoryCheck.test.ts` | MUST | PENDING |

### Integration Tests
| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| ModelStore.initContext() uses new memory check | Manual | SHOULD | PENDING |

### Manual Testing
- [ ] Test on Android device (Pixel 9 preferred for validation)
- [ ] Verify debug logs show "Actual available" vs "Heuristic estimate"
- [ ] Load model near memory limit - should not crash
- [ ] Compare memory estimation accuracy to heuristic

---

## Coding Standards

### Testing Infrastructure (CRITICAL)
```
# Read these BEFORE writing tests:
${WORKTREE_PATH}/jest/setup.ts      # Global mocks
${WORKTREE_PATH}/jest/test-utils.tsx # Custom render
${WORKTREE_PATH}/__mocks__/stores/  # Mock stores

# DO NOT mock stores inline - they're globally mocked
# Use runInAction() for MobX state changes
# Import render from jest/test-utils, NOT @testing-library/react-native
```

### Patterns to Follow
- **Native Modules**: Follow existing TurboModule pattern in `HardwareInfoModule.kt` and `HardwareInfoModule.mm`
- **Hooks**: Follow existing hook pattern in `useMemoryCheck.ts` (async, error handling)
- **Types**: Strict TypeScript, avoid `any`
- **Error Handling**: Always have try-catch with graceful fallback

### Commit Format (enforced by commitlint)
```
type(scope): subject
```

**Rules**:
- Header max: 100 chars total
- Types allowed: `feat`, `fix`, `docs`, `chore` (only these 4)
- No Co-Authored-By needed
- Keep it short and clear

**Examples**:
```
feat(memory): add native getAvailableMemory() API
fix(memory): fallback to heuristic if native API fails
chore(native): update HardwareInfoModule with memory API
```

### Naming Conventions
- Native methods: camelCase (`getAvailableMemory`)
- TypeScript: camelCase for functions, PascalCase for types/interfaces
- Test files: Match source file name with `.test.ts` suffix

---

## Reference Code

### Pattern Example: Android File Reading
**File**: `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt`
**Lines**: 133-197
```kotlin
override fun getCPUInfo(promise: Promise) {
  try {
    val cpuInfo = Arguments.createMap()
    cpuInfo.putInt("cores", Runtime.getRuntime().availableProcessors())

    val processors = Arguments.createArray()
    val features = mutableSetOf<String>()
    val cpuInfoFile = File("/proc/cpuinfo")

    if (cpuInfoFile.exists()) {
      val cpuInfoLines = cpuInfoFile.readLines()
      var currentProcessor = Arguments.createMap()
      var hasData = false

      for (line in cpuInfoLines) {
        // ... parse lines ...
      }
    }
    
    promise.resolve(cpuInfo)
  } catch (e: Exception) {
    promise.reject("ERROR", e.message)
  }
}
```

### Pattern Example: iOS Promise Method
**File**: `ios/PocketPal/HardwareInfoModule.mm`
**Lines**: 12-26
```objective-c
RCT_EXPORT_METHOD(getCPUInfo:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
  @try {
    NSUInteger numberOfCPUCores = [[NSProcessInfo processInfo] activeProcessorCount];

    NSDictionary *result = @{
      @"cores": @(numberOfCPUCores)
    };

    resolve(result);
  } @catch (NSException *exception) {
    reject(@"error_getting_cpu_info", @"Could not retrieve CPU info", nil);
  }
}
```

### Pattern Example: Calling Native API
**File**: `src/utils/deviceCapabilities.ts`
**Lines**: 85-88
```typescript
const [gpuInfo, cpuInfo] = await Promise.all([
  NativeHardwareInfo.getGPUInfo(),
  NativeHardwareInfo.getCPUInfo(),
]);
```

---

## Dependencies

### Blocked By
- None

### Blocks
- None (standalone improvement)

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `ActivityManager.getMemoryInfo()` unavailable | Very Low | Medium | API available since Android API 1; fallback to heuristic |
| `os_proc_available_memory()` requires iOS 13+ | Low | Low | PocketPal already targets iOS 14+, documented in code |
| Native API returns incorrect value | Low | High | 10% safety margin + debug logging for validation |
| Performance overhead of API call | Very Low | Low | ActivityManager API is fast, only called once per model load |
| Breaking existing tests | Medium | Medium | Update mocks comprehensively in Step 5 |
| iOS build fails after adding new method | Medium | Medium | Follow exact TurboModule codegen pattern, test builds in Step 7 |
| Android build fails with Kotlin compilation error | Medium | Medium | Follow existing method patterns in HardwareInfoModule.kt |

---

## Open Questions

### For Human
- [ ] Should we add caching for `getAvailableMemory()` to reduce native calls? (Current: called once per model load, probably fine)
- [ ] Should we expose this API to users in DeviceInfoCard screen? (Current: internal only)
- [ ] Should we collect telemetry on actual vs heuristic memory to validate improvement? (Analytics)

### Resolved
- [x] **Which Android API to use?** → Use `ActivityManager.getMemoryInfo()` instead of `/proc/meminfo`
  - Official Android API, works reliably across all devices
  - No SELinux permission issues on newer Android or OEM ROMs
  - `availMem` equals `MemFree + Cached` from /proc/meminfo (same data)
  - Sources: [Android Developers](https://developer.android.com/reference/android/app/ActivityManager.MemoryInfo), [Memory Management Guide](https://developer.android.com/topic/performance/memory)

---

## Agent Reports

### Planner Report
```
Research completed: 2026-01-26
Agent: pocketpal-planner

Findings:
1. Current memory estimation in useMemoryCheck.ts uses heuristic formula
2. Native modules exist for CPU/GPU info, but not memory
3. iOS has os_proc_available_memory() API available (iOS 12+, PocketPal targets 14+)
4. TurboModule pattern requires: Spec update -> Native implementation -> JS usage
5. Tests mock NativeHardwareInfo globally in jest/setup.ts
6. ModelStore.initContext() calls hasEnoughMemory() at line 1031

Android API Research (Updated):
- Initially planned to use /proc/meminfo (Linux kernel interface)
- After research, switched to ActivityManager.getMemoryInfo() because:
  * Official Android API - works reliably across all devices
  * No SELinux permission issues on newer Android or OEM ROMs
  * Abstracts kernel differences (MemAvailable added in Linux 3.14)
  * Same data: availMem equals MemFree + Cached from /proc/meminfo
  * Sources: developer.android.com/reference/android/app/ActivityManager.MemoryInfo

Key files researched:
- android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt (198 lines)
- ios/PocketPal/HardwareInfoModule.mm (63 lines)
- src/specs/NativeHardwareInfo.ts (40 lines)
- src/hooks/useMemoryCheck.ts (74 lines)
- jest/setup.ts (mocking patterns)

Implementation approach:
1. Add native methods (Android: ActivityManager, iOS: os_proc_available_memory)
2. Update TurboModule spec
3. Update JS logic with fallback
4. Update test mocks
5. Platform builds verification

Risks: Minimal - fallback to heuristic ensures no regression. Safety margin prevents over-estimation.

Story complexity: Standard (requires native code + tests)
```

### Implementation Report
```
Date: 2026-01-26
Agent: pocketpal-implementer

Environment:
- Task ID: TASK-20260126-1433
- Worktree: /Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260126-1433
- Branch: feature/TASK-20260126-1433

Story: Fix Memory Estimation for Model Loading by Adding Native getAvailableMemory() API

Status: COMPLETE

Changes Made:

| File | Change | Commit |
|------|--------|--------|
| android/app/.../HardwareInfoModule.kt | Added getAvailableMemory() using ActivityManager | a4e3e41 |
| ios/PocketPal/HardwareInfoModule.mm | Added getAvailableMemory() using os_proc_available_memory() | 85f65e4 |
| src/specs/NativeHardwareInfo.ts | Added getAvailableMemory() to Spec interface | 044dd9a |
| src/hooks/useMemoryCheck.ts | Updated to use native API with 10% margin + fallback | 3067109 |
| jest/setup.ts | Added getAvailableMemory mock (3GB) | d249574 |
| jest/fixtures/device-info.ts | Added availableMemory: 3GB | d249574 |
| ios/PocketPal/HardwareInfoModule.mm | Fixed header to use <os/proc.h> | 5016e1b |

Implementation Details:
1. Android: Uses ActivityManager.getMemoryInfo().availMem - official API, no permission issues
2. iOS: Uses os_proc_available_memory() from <os/proc.h> header
3. JavaScript: Applies 10% safety margin, falls back to heuristic on error
4. Debug logging added to compare actual vs heuristic in __DEV__ mode
5. All existing tests pass with updated mocks

Deviations from Plan:
- Android: Used ActivityManager.getMemoryInfo() instead of /proc/meminfo
  Reason: Official API, more reliable, no SELinux permission issues on newer Android
- iOS: Fixed header from <sys/sysctl.h> to <os/proc.h>
  Reason: os_proc_available_memory() requires <os/proc.h>
- Mock memory: Increased from 2.5GB to 3GB
  Reason: After 10% margin (2.7GB), needed to fit 2GB test model (requires 2.27GB)

Verification Results:
- Lint: PASS (only pre-existing warnings in other files)
- TypeCheck: PASS
- Tests: PASS (3/3 tests in useMemoryCheck.test.ts)
- Pod Install: PASS (no Podfile.lock changes)
- iOS Build: PASS (Release configuration, iphonesimulator)
- Android Build: PASS (assembleRelease)

Notes for Tester:
- New tests needed for:
  1. Native API returns correct value
  2. Fallback works when native API fails
  3. 10% safety margin is applied correctly
- Mock is configured at 3GB available memory
- NativeHardwareInfo.getAvailableMemory is mocked in jest/setup.ts
- Test pattern should follow existing useMemoryCheck tests

Blockers: None
```

### Test Report
```
[Filled by tester after tests written]
```

### Phase 2 Implementation Report
```
Date: 2026-01-26
Agent: pocketpal-implementer

Environment:
- Task ID: TASK-20260126-1433
- Worktree: /Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260126-1433
- Branch: feature/TASK-20260126-1433

Story: Phase 2 - Track Loaded Model Memory for Accurate Model Switching

Status: COMPLETE

Changes Made:

| File | Change | Commit |
|------|--------|--------|
| src/store/ModelStore.ts | Added loadedModelMemoryUsage observable | df836c9 |
| src/store/ModelStore.ts | Import NativeHardwareInfo | d03d4f5 |
| src/store/ModelStore.ts | Measure memory before/after model load | d03d4f5 |
| src/store/ModelStore.ts | Clear loadedModelMemoryUsage on release | 65176a4 |
| src/hooks/useMemoryCheck.ts | Import modelStore | ed04082 |
| src/hooks/useMemoryCheck.ts | Calculate effective available memory | ed04082 |
| src/store/ModelStore.ts | Prettier formatting fix | b46f15b |
| __mocks__/stores/modelStore.ts | Add loadedModelMemoryUsage to mock | 1ad99e6 |
| __mocks__/stores/modelStore.ts | Add isMultimodalActive to mock | 1ad99e6 |
| src/hooks/__tests__/useMemoryCheck.test.ts | Add 3 Phase 2 tests | 1ad99e6 |

Implementation Details:
1. ModelStore now tracks actual memory consumption during model load
2. Measures memory before and after initLlama() call
3. Stores delta in loadedModelMemoryUsage observable (bytes)
4. Only stores positive deltas (sanity check)
5. Clears tracking when context is released (finally block)
6. hasEnoughMemory() now calculates effective available memory:
   - If loadedModelMemoryUsage exists: uses actual measured value
   - Else if activeModel exists: uses estimated memory requirement
   - Else: uses raw available memory (no adjustment)
7. Debug logging added to show measured vs estimated memory

Deviations from Plan:
- None - followed phase plan exactly

Verification Results:
- Lint: PASS (only pre-existing warnings)
- TypeCheck: PASS
- Tests: PASS (all 1361 tests, 9/9 in useMemoryCheck.test.ts)
- Coverage: Tests cover all 3 scenarios (actual, estimate, no model)
- No platform builds needed (JS-only changes)

Notes for Reviewer:
- Phase 2 is pure JavaScript - no native changes
- All new code paths are tested
- Memory tracking is defensive (undefined fallback)
- Debug logs will help validate accuracy in production
- Effective available calculation enables better model switching UX
  (Users won't see "not enough memory" when switching models)

Blockers: None
```

### Review Report
```
[Filled by reviewer after review]
```

---

## Changelog

| Date | Agent/Human | Change |
|------|-------------|--------|
| 2026-01-26 | orchestrator | Created worktree and task |
| 2026-01-26 | planner | Initial story draft with detailed research |
