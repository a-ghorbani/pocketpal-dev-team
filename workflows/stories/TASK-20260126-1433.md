# Story: Fix Memory Estimation for Model Loading by Adding Native getAvailableMemory() API

## Metadata
- **Task ID**: TASK-20260126-1433
- **Issue**: Action Tracker Item - "Memory Estimation for Model Loading"
- **Source**: action-tracker (P2 priority)
- **Complexity**: standard
- **Native Changes**: YES
- **Created**: 2026-01-26
- **Status**: draft

## Environment
- **Worktree**: `/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260126-1433`
- **Branch**: `feature/TASK-20260126-1433`
- **Base**: `main`

---

## Progress Tracking

### Current Phase
`[X] Planning → [X] Approved → [X] Implementing → [ ] Testing → [ ] Reviewing → [ ] PR Created`

### Checkpoints (Updated by Agents)

| Checkpoint | Status | Agent | Commit | Notes |
|------------|--------|-------|--------|-------|
| Worktree created | DONE | orchestrator | - | |
| Story approved | DONE | human | - | |
| Step 1 complete | DONE | implementer | a4e3e41 | Android getAvailableMemory() |
| Step 2 complete | DONE | implementer | 85f65e4 | iOS getAvailableMemory() |
| Step 3 complete | DONE | implementer | 044dd9a | Update TurboModule spec |
| Step 4 complete | DONE | implementer | 3067109 | Update useMemoryCheck logic |
| Step 5 complete | DONE | implementer | d249574 | Update mocks |
| iOS header fix | DONE | implementer | 5016e1b | Fixed os/proc.h import |
| Tests verified | DONE | implementer | - | Existing tests pass |
| Platform builds | DONE | implementer | - | iOS and Android succeed |
| Tests written | PENDING | tester | - | |
| Review passed | PENDING | reviewer | - | |
| PR created | PENDING | reviewer | - | |

### Last Agent Handoff
```yaml
from_agent: implementer
to_agent: tester
timestamp: 2026-01-26T15:00:00Z
status: "Implementation complete, ready for tests"
completed:
  - Step 1: Added getAvailableMemory() to Android module (commit a4e3e41)
  - Step 2: Added getAvailableMemory() to iOS module (commit 85f65e4)
  - Step 3: Updated TurboModule spec (commit 044dd9a)
  - Step 4: Updated useMemoryCheck to use native API (commit 3067109)
  - Step 5: Updated test mocks (commit d249574)
  - Fixed iOS header import (commit 5016e1b)
  - Verified iOS build succeeds (Release configuration)
  - Verified Android build succeeds (Release APK)
  - Verified existing tests pass
next_steps:
  - Write unit tests for new native API usage
  - Write integration tests
  - Run full test suite
blockers: []
context_for_next_agent: |
  Implementation complete with all 6 commits.
  Native changes verified on both iOS and Android.
  Android uses ActivityManager.getMemoryInfo() - official API, no permission issues.
  iOS uses os_proc_available_memory() from <os/proc.h>.
  10% safety margin applied in useMemoryCheck.ts.
  Fallback to heuristic implemented for robustness.
  Existing tests pass - mock returns 3GB available memory.
  See Implementation Report below for details.
```

---

## Context (For Recovery After Context Reset)

> **If you're an agent resuming work on this story:**
> 1. Read the "Progress Tracking" section above
> 2. Check `git log` in the worktree for commits
> 3. Read the "Last Agent Handoff" section
> 4. Continue from the next incomplete checkpoint

### Background

PocketPal AI currently uses a heuristic formula to estimate available memory for model loading:
```typescript
const availableMemory = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
```

This formula was created based on limited device testing and overestimates available memory on high-end devices. For example:
- **Pixel 9 (12GB RAM)**: Formula estimates 7.7GB available, but actual is 6.3GB (22% overestimate)
- **OnePlus 6 (8GB RAM)**: Formula estimates 5.2GB available, actual is ~4.8GB (8% overestimate)

This causes Out-Of-Memory (OOM) crashes, which account for ~10% of total app crashes (18 OOM crashes reported with signatures like `lm_ggml_gallocr_alloc_graph`, `lm_ggml_abort`).

User feedback validates this: "Unsuitable Model Size Recommendations For Device" mentioned 3x in recent feedback.

The solution is to query the OS directly for **actual available memory** instead of estimating.

### Current State

**File**: `src/hooks/useMemoryCheck.ts`
- Imports `DeviceInfo.getTotalMemory()` from `react-native-device-info`
- Calculates `availableMemory` using heuristic: `Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2)`
- Exports `hasEnoughMemory(modelSize, isMultimodal)` function
- Used by `ModelStore.initContext()` to check if model can load (line 1031 in ModelStore.ts)

**File**: `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt`
- TurboModule that provides `getCPUInfo()`, `getGPUInfo()`, `getChipset()`
- Does NOT currently provide memory information
- Follows React Native TurboModule pattern (extends `NativeHardwareInfoSpec`)

**File**: `ios/PocketPal/HardwareInfoModule.mm`
- Objective-C++ module that provides `getCPUInfo()`, `getGPUInfo()`
- Does NOT currently provide memory information
- Uses `RCT_EXPORT_METHOD` macros

**File**: `src/specs/NativeHardwareInfo.ts`
- TurboModule spec defining the interface for native modules
- Exports `CPUInfo`, `GPUInfo` interfaces
- Does NOT include memory methods

**File**: `jest/setup.ts` (lines 56-75)
- Mocks `NativeHardwareInfo` globally for tests
- Returns mock data for `getCPUInfo()` and `getGPUInfo()`

**File**: `__mocks__/external/react-native-device-info.js`
- Mocks `DeviceInfo.getTotalMemory()` and `getUsedMemory()` 
- Uses fixtures from `jest/fixtures/device-info.ts`

### Target State

After this change:
1. `NativeHardwareInfo` TurboModule exposes `getAvailableMemory(): Promise<number>` method
2. Android implementation reads `/proc/meminfo` MemAvailable field
3. iOS implementation uses `os_proc_available_memory()` API
4. `useMemoryCheck.ts` uses native available memory with 10% safety margin + fallback to heuristic
5. Tests updated to mock `getAvailableMemory()` 
6. Platform builds succeed (pod install, iOS/Android release builds)

---

## Requirements

### Functional
1. [MUST] Android `HardwareInfoModule.kt` implements `getAvailableMemory()` using `ActivityManager.getMemoryInfo()` (official Android API)
2. [MUST] iOS `HardwareInfoModule.mm` implements `getAvailableMemory()` using `os_proc_available_memory()` API
3. [MUST] `NativeHardwareInfo.ts` TurboModule spec includes `getAvailableMemory(): Promise<number>` method
4. [MUST] `useMemoryCheck.ts` calls native `getAvailableMemory()` instead of calculating heuristic
5. [MUST] Apply 10% safety margin to available memory (return `availableMemory * 0.9`)
6. [MUST] Fallback to current heuristic if native API fails (for robustness)
7. [MUST] Update test mocks in `jest/setup.ts` and `__mocks__/external/react-native-device-info.js`
8. [SHOULD] Log actual vs estimated memory in debug builds for validation

### Non-Functional
- **Performance**: Native call should be fast (<10ms), cached if called frequently
- **Compatibility**: Must work on Android API 21+ and iOS 14+
- **Reliability**: Must not crash if API unavailable (graceful fallback)
- **Testing**: Must maintain 60%+ test coverage

### Platform Verification (NATIVE_CHANGES=YES)
- [ ] `pod install` succeeds
- [ ] iOS Release build succeeds
- [ ] Android Release build succeeds
- [ ] `ios/Podfile.lock` changes committed (if any)

---

## Acceptance Criteria

- [ ] Android uses `ActivityManager.getMemoryInfo()` and returns `availMem` in bytes
- [ ] iOS uses `os_proc_available_memory()` and returns bytes
- [ ] `getAvailableMemory()` returns actual available memory in bytes
- [ ] `useMemoryCheck.ts` applies 10% safety margin
- [ ] If native call fails, falls back to heuristic (no crash)
- [ ] All existing tests pass
- [ ] New tests added for `getAvailableMemory()` 
- [ ] Coverage >= 60%
- [ ] Platform builds succeed (iOS + Android Release)
- [ ] Manual testing on real device shows accurate memory estimation

---

## Affected Files

| File | Action | Reason | Status |
|------|--------|--------|--------|
| `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt` | MODIFY | Add getAvailableMemory() method | PENDING |
| `ios/PocketPal/HardwareInfoModule.mm` | MODIFY | Add getAvailableMemory() method | PENDING |
| `src/specs/NativeHardwareInfo.ts` | MODIFY | Add getAvailableMemory() to Spec interface | PENDING |
| `src/hooks/useMemoryCheck.ts` | MODIFY | Use native API instead of heuristic | PENDING |
| `src/hooks/__tests__/useMemoryCheck.test.ts` | MODIFY | Update tests to verify native API usage | PENDING |
| `jest/setup.ts` | MODIFY | Add getAvailableMemory() to NativeHardwareInfo mock | PENDING |
| `__mocks__/external/react-native-device-info.js` | MODIFY | (Optional) Add getAvailableMemory() if needed | PENDING |
| `jest/fixtures/device-info.ts` | MODIFY | Add availableMemory fixture data | PENDING |
| `ios/Podfile.lock` | UPDATE | May change after pod install | PENDING |

---

## Implementation Plan

### Step 1: Add getAvailableMemory() to Android Native Module
**Files**: `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add import for `android.app.ActivityManager` and `android.content.Context`
- [ ] Add `getAvailableMemory(promise: Promise)` method to `HardwareInfoModule` class
- [ ] Override method from `NativeHardwareInfoSpec` (will be added in Step 3)
- [ ] Use `ActivityManager.getMemoryInfo()` to get available memory (official Android API)
- [ ] Resolve promise with `memInfo.availMem` as Double (already in bytes)
- [ ] Handle errors gracefully (reject promise with error message)

**Why ActivityManager instead of /proc/meminfo:**
- Official Android API - works reliably across all devices and Android versions
- No SELinux permission issues on newer Android or OEM ROMs
- Abstracts away kernel differences (MemAvailable wasn't added until Linux 3.14)
- Provides bonus `lowMemory` flag for free
- Same underlying data: `availMem` equals `MemFree + Cached` from /proc/meminfo

**Pattern Reference**: See `HardwareInfoModule.kt:133-197` (getCPUInfo method) for promise pattern

**Code Guidance**:
```kotlin
// Add imports at top of file
import android.app.ActivityManager
import android.content.Context

// Add method in HardwareInfoModule class
override fun getAvailableMemory(promise: Promise) {
  try {
    val activityManager = reactApplicationContext
      .getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
    val memInfo = ActivityManager.MemoryInfo()
    activityManager.getMemoryInfo(memInfo)

    // availMem is already in bytes
    promise.resolve(memInfo.availMem.toDouble())
  } catch (e: Exception) {
    promise.reject("ERROR", e.message)
  }
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn lint
yarn typecheck
```

### Step 2: Add getAvailableMemory() to iOS Native Module
**Files**: `ios/PocketPal/HardwareInfoModule.mm`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Import `<mach/mach.h>` and `<sys/sysctl.h>` headers at top
- [ ] Add `RCT_EXPORT_METHOD(getAvailableMemory:...)` 
- [ ] Call `os_proc_available_memory()` to get available memory in bytes
- [ ] Resolve promise with bytes as NSNumber
- [ ] Handle errors gracefully (catch exceptions, reject promise)

**Pattern Reference**: See `HardwareInfoModule.mm:12-26` (getCPUInfo method) for promise pattern

**Code Guidance**:
```objective-c
#import <React/RCTBridgeModule.h>
#import <UIKit/UIKit.h>
#import <Metal/Metal.h>
#import <mach/mach.h>
#import <sys/sysctl.h>

// ... existing code ...

RCT_EXPORT_METHOD(getAvailableMemory:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
  @try {
    // Get available memory using os_proc_available_memory()
    uint64_t availableMemory = os_proc_available_memory();
    
    if (availableMemory == 0) {
      reject(@"error_getting_available_memory", @"Could not retrieve available memory", nil);
      return;
    }
    
    resolve(@(availableMemory));
  } @catch (NSException *exception) {
    reject(@"error_getting_available_memory", @"Could not retrieve available memory", nil);
  }
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn lint
yarn typecheck
```

### Step 3: Update TurboModule Spec
**Files**: `src/specs/NativeHardwareInfo.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add `getAvailableMemory(): Promise<number>` to `Spec` interface (line 33-37)
- [ ] Add JSDoc comment explaining return value (bytes)

**Pattern Reference**: See `NativeHardwareInfo.ts:34-36` (getCPUInfo, getGPUInfo methods)

**Code Guidance**:
```typescript
export interface Spec extends TurboModule {
  getCPUInfo(): Promise<CPUInfo>;
  getGPUInfo(): Promise<GPUInfo>;
  getChipset?(): Promise<string>; // Android only
  /**
   * Get available memory in bytes from the operating system.
   * - Android: Reads MemAvailable from /proc/meminfo
   * - iOS: Uses os_proc_available_memory()
   * @returns Promise<number> Available memory in bytes
   */
  getAvailableMemory(): Promise<number>;
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
```

### Step 4: Update useMemoryCheck to Use Native API
**Files**: `src/hooks/useMemoryCheck.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Import `NativeHardwareInfo` at top: `import NativeHardwareInfo from '../specs/NativeHardwareInfo';`
- [ ] Replace `hasEnoughMemory()` implementation (lines 20-30):
  - Call `NativeHardwareInfo.getAvailableMemory()` to get actual available memory
  - Apply 10% safety margin: `actualAvailable * 0.9`
  - If native call fails, fallback to current heuristic formula
  - Add console.log in debug mode to compare actual vs heuristic
- [ ] Keep `memoryRequirementEstimate()` unchanged (model requirement calculation is correct)

**Pattern Reference**: See `src/utils/deviceCapabilities.ts:85-88` for calling NativeHardwareInfo pattern

**Code Guidance**:
```typescript
export const hasEnoughMemory = async (
  modelSize: number,
  isMultimodal = false,
): Promise<boolean> => {
  let availableMemoryGB: number;

  try {
    // Try native API first (actual available memory from OS)
    const availableBytes = await NativeHardwareInfo.getAvailableMemory();
    // Apply 10% safety margin
    const safeAvailableBytes = availableBytes * 0.9;
    availableMemoryGB = safeAvailableBytes / 1000 / 1000 / 1000;
    
    // Debug logging to validate accuracy
    if (__DEV__) {
      const totalMemory = await DeviceInfo.getTotalMemory();
      const totalMemoryGB = totalMemory / 1000 / 1000 / 1000;
      const heuristicAvailable = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
      console.log('[MemoryCheck] Actual available:', availableMemoryGB.toFixed(2), 'GB');
      console.log('[MemoryCheck] Heuristic estimate:', heuristicAvailable.toFixed(2), 'GB');
      console.log('[MemoryCheck] Difference:', ((heuristicAvailable - availableMemoryGB) / availableMemoryGB * 100).toFixed(1), '%');
    }
  } catch (error) {
    // Fallback to heuristic if native API fails
    console.warn('[MemoryCheck] Native API failed, using heuristic:', error);
    const totalMemory = await DeviceInfo.getTotalMemory();
    const totalMemoryGB = totalMemory / 1000 / 1000 / 1000;
    availableMemoryGB = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
  }

  const memoryRequirement = memoryRequirementEstimate(modelSize, isMultimodal);
  return memoryRequirement <= availableMemoryGB;
};
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn lint
yarn typecheck
yarn test --findRelatedTests src/hooks/useMemoryCheck.ts
```

### Step 5: Update Test Mocks
**Files**: `jest/setup.ts`, `jest/fixtures/device-info.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] In `jest/setup.ts` (lines 56-75), add `getAvailableMemory` to NativeHardwareInfo mock
- [ ] Mock should return realistic value: ~2.5GB available for 4GB total device
- [ ] In `jest/fixtures/device-info.ts`, add `availableMemory: 2.5 * 1000 ** 3` to fixture
- [ ] Ensure mock is consistent with totalMemory (availableMemory < totalMemory)

**Pattern Reference**: See `jest/setup.ts:60-74` for existing NativeHardwareInfo mock structure

**Code Guidance**:
```typescript
// jest/setup.ts (add to existing mock around line 74)
jest.mock('../src/specs/NativeHardwareInfo', () => ({
  __esModule: true,
  default: {
    getCPUInfo: jest.fn(() => Promise.resolve({cores: 4})),
    getGPUInfo: jest.fn(() =>
      Promise.resolve({
        renderer: 'Mock GPU',
        vendor: 'Mock Vendor',
        version: 'Mock Version',
        hasAdreno: false,
        hasMali: false,
        hasPowerVR: false,
        supportsOpenCL: false,
        gpuType: 'Mock GPU',
      }),
    ),
    getChipset: jest.fn(() => Promise.resolve('Mock Chipset')),
    getAvailableMemory: jest.fn(() => Promise.resolve(2.5 * 1000 * 1000 * 1000)), // 2.5GB
  },
}));
```

```typescript
// jest/fixtures/device-info.ts (add to deviceInfo object)
export const deviceInfo = {
  freeDiskStorage: 8 * 1000 ** 3,
  totalMemory: 4 * 1000 ** 3,
  usedMemory: 2 * 1000 ** 3,
  availableMemory: 2.5 * 1000 ** 3, // More accurate than totalMemory - usedMemory
  version: '1.0.0',
  buildNumber: '1',
};
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn test
```

### Step 6: Update useMemoryCheck Tests
**Files**: `src/hooks/__tests__/useMemoryCheck.test.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add test: "should use native getAvailableMemory() API"
- [ ] Add test: "should fallback to heuristic if native API fails"
- [ ] Add test: "should apply 10% safety margin to native available memory"
- [ ] Verify existing tests still pass with new implementation

**Pattern Reference**: See `useMemoryCheck.test.ts:58-92` for error handling test pattern

**Code Guidance**:
```typescript
import NativeHardwareInfo from '../../specs/NativeHardwareInfo';

// Add after existing tests
it('should use native getAvailableMemory() API', async () => {
  // Mock native API to return 3GB available
  (NativeHardwareInfo.getAvailableMemory as jest.Mock).mockResolvedValue(
    3 * 1000 * 1000 * 1000
  );

  const {result, waitForNextUpdate} = renderHook(() =>
    useMemoryCheck(localModel.size),
  );

  try {
    await waitForNextUpdate();
  } catch {
    // Ignoring timeout
  }

  // Should pass because model is small and 3GB * 0.9 = 2.7GB available
  expect(result.current).toEqual({
    memoryWarning: '',
    shortMemoryWarning: '',
    multimodalWarning: '',
  });
  
  expect(NativeHardwareInfo.getAvailableMemory).toHaveBeenCalled();
});

it('should fallback to heuristic if native API fails', async () => {
  (NativeHardwareInfo.getAvailableMemory as jest.Mock).mockRejectedValue(
    new Error('Native API error')
  );

  const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const {result, waitForNextUpdate} = renderHook(() =>
    useMemoryCheck(localModel.size),
  );

  try {
    await waitForNextUpdate();
  } catch {
    // Ignoring timeout
  }

  // Should still work with fallback
  expect(result.current.memoryWarning).toBe('');
  expect(consoleWarnSpy).toHaveBeenCalledWith(
    expect.stringContaining('Native API failed'),
    expect.any(Error)
  );

  consoleWarnSpy.mockRestore();
});

it('should apply 10% safety margin to available memory', async () => {
  // Mock exactly enough memory (3.5GB available)
  // Model needs ~3.2GB (after margin it's 3.15GB available)
  const modelSize = 3.5 * 1000 * 1000 * 1000; // 3.5GB model
  (NativeHardwareInfo.getAvailableMemory as jest.Mock).mockResolvedValue(
    3.5 * 1000 * 1000 * 1000
  );

  const {result, waitForNextUpdate} = renderHook(() =>
    useMemoryCheck(modelSize),
  );

  try {
    await waitForNextUpdate();
  } catch {
    // Ignoring timeout
  }

  // After 10% margin, 3.5GB becomes 3.15GB available
  // Model requirement: 0.43 + (0.92 * 3.5) = 3.65GB
  // Should show warning because 3.65GB > 3.15GB
  expect(result.current.memoryWarning).toBe(l10n.en.memory.warning);
});
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn test src/hooks/__tests__/useMemoryCheck.test.ts
```

### Step 7: Platform Verification (NATIVE_CHANGES=YES)
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Run `cd ios && pod install && cd ..`
- [ ] Commit Podfile.lock changes (if any)
- [ ] Run `yarn ios --configuration Release` (verify iOS build succeeds)
- [ ] Run `yarn android --variant=release` (verify Android build succeeds)
- [ ] Test on real device (optional but recommended for validation)

**Verification**:
```bash
cd "${WORKTREE_PATH}"

# iOS
cd ios && pod install && cd ..
yarn ios --configuration Release

# Android
yarn android --variant=release

# Manual test on device
# 1. Open app on physical device
# 2. Check logs for "[MemoryCheck] Actual available" debug output
# 3. Try loading a model near memory limit
# 4. Verify no OOM crash
```

---

## Test Requirements

### Unit Tests
| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| Should use native getAvailableMemory() API | `useMemoryCheck.test.ts` | MUST | PENDING |
| Should fallback to heuristic if native API fails | `useMemoryCheck.test.ts` | MUST | PENDING |
| Should apply 10% safety margin | `useMemoryCheck.test.ts` | MUST | PENDING |
| Existing: returns no warning when safe | `useMemoryCheck.test.ts` | MUST | PENDING |
| Existing: returns warning when unsafe | `useMemoryCheck.test.ts` | MUST | PENDING |
| Existing: handles errors gracefully | `useMemoryCheck.test.ts` | MUST | PENDING |

### Integration Tests
| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| ModelStore.initContext() uses new memory check | Manual | SHOULD | PENDING |

### Manual Testing
- [ ] Test on Android device (Pixel 9 preferred for validation)
- [ ] Verify debug logs show "Actual available" vs "Heuristic estimate"
- [ ] Load model near memory limit - should not crash
- [ ] Compare memory estimation accuracy to heuristic

---

## Coding Standards

### Testing Infrastructure (CRITICAL)
```
# Read these BEFORE writing tests:
${WORKTREE_PATH}/jest/setup.ts      # Global mocks
${WORKTREE_PATH}/jest/test-utils.tsx # Custom render
${WORKTREE_PATH}/__mocks__/stores/  # Mock stores

# DO NOT mock stores inline - they're globally mocked
# Use runInAction() for MobX state changes
# Import render from jest/test-utils, NOT @testing-library/react-native
```

### Patterns to Follow
- **Native Modules**: Follow existing TurboModule pattern in `HardwareInfoModule.kt` and `HardwareInfoModule.mm`
- **Hooks**: Follow existing hook pattern in `useMemoryCheck.ts` (async, error handling)
- **Types**: Strict TypeScript, avoid `any`
- **Error Handling**: Always have try-catch with graceful fallback

### Commit Format (enforced by commitlint)
```
type(scope): subject
```

**Rules**:
- Header max: 100 chars total
- Types allowed: `feat`, `fix`, `docs`, `chore` (only these 4)
- No Co-Authored-By needed
- Keep it short and clear

**Examples**:
```
feat(memory): add native getAvailableMemory() API
fix(memory): fallback to heuristic if native API fails
chore(native): update HardwareInfoModule with memory API
```

### Naming Conventions
- Native methods: camelCase (`getAvailableMemory`)
- TypeScript: camelCase for functions, PascalCase for types/interfaces
- Test files: Match source file name with `.test.ts` suffix

---

## Reference Code

### Pattern Example: Android File Reading
**File**: `android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt`
**Lines**: 133-197
```kotlin
override fun getCPUInfo(promise: Promise) {
  try {
    val cpuInfo = Arguments.createMap()
    cpuInfo.putInt("cores", Runtime.getRuntime().availableProcessors())

    val processors = Arguments.createArray()
    val features = mutableSetOf<String>()
    val cpuInfoFile = File("/proc/cpuinfo")

    if (cpuInfoFile.exists()) {
      val cpuInfoLines = cpuInfoFile.readLines()
      var currentProcessor = Arguments.createMap()
      var hasData = false

      for (line in cpuInfoLines) {
        // ... parse lines ...
      }
    }
    
    promise.resolve(cpuInfo)
  } catch (e: Exception) {
    promise.reject("ERROR", e.message)
  }
}
```

### Pattern Example: iOS Promise Method
**File**: `ios/PocketPal/HardwareInfoModule.mm`
**Lines**: 12-26
```objective-c
RCT_EXPORT_METHOD(getCPUInfo:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
  @try {
    NSUInteger numberOfCPUCores = [[NSProcessInfo processInfo] activeProcessorCount];

    NSDictionary *result = @{
      @"cores": @(numberOfCPUCores)
    };

    resolve(result);
  } @catch (NSException *exception) {
    reject(@"error_getting_cpu_info", @"Could not retrieve CPU info", nil);
  }
}
```

### Pattern Example: Calling Native API
**File**: `src/utils/deviceCapabilities.ts`
**Lines**: 85-88
```typescript
const [gpuInfo, cpuInfo] = await Promise.all([
  NativeHardwareInfo.getGPUInfo(),
  NativeHardwareInfo.getCPUInfo(),
]);
```

---

## Dependencies

### Blocked By
- None

### Blocks
- None (standalone improvement)

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `ActivityManager.getMemoryInfo()` unavailable | Very Low | Medium | API available since Android API 1; fallback to heuristic |
| `os_proc_available_memory()` requires iOS 13+ | Low | Low | PocketPal already targets iOS 14+, documented in code |
| Native API returns incorrect value | Low | High | 10% safety margin + debug logging for validation |
| Performance overhead of API call | Very Low | Low | ActivityManager API is fast, only called once per model load |
| Breaking existing tests | Medium | Medium | Update mocks comprehensively in Step 5 |
| iOS build fails after adding new method | Medium | Medium | Follow exact TurboModule codegen pattern, test builds in Step 7 |
| Android build fails with Kotlin compilation error | Medium | Medium | Follow existing method patterns in HardwareInfoModule.kt |

---

## Open Questions

### For Human
- [ ] Should we add caching for `getAvailableMemory()` to reduce native calls? (Current: called once per model load, probably fine)
- [ ] Should we expose this API to users in DeviceInfoCard screen? (Current: internal only)
- [ ] Should we collect telemetry on actual vs heuristic memory to validate improvement? (Analytics)

### Resolved
- [x] **Which Android API to use?** → Use `ActivityManager.getMemoryInfo()` instead of `/proc/meminfo`
  - Official Android API, works reliably across all devices
  - No SELinux permission issues on newer Android or OEM ROMs
  - `availMem` equals `MemFree + Cached` from /proc/meminfo (same data)
  - Sources: [Android Developers](https://developer.android.com/reference/android/app/ActivityManager.MemoryInfo), [Memory Management Guide](https://developer.android.com/topic/performance/memory)

---

## Agent Reports

### Planner Report
```
Research completed: 2026-01-26
Agent: pocketpal-planner

Findings:
1. Current memory estimation in useMemoryCheck.ts uses heuristic formula
2. Native modules exist for CPU/GPU info, but not memory
3. iOS has os_proc_available_memory() API available (iOS 12+, PocketPal targets 14+)
4. TurboModule pattern requires: Spec update -> Native implementation -> JS usage
5. Tests mock NativeHardwareInfo globally in jest/setup.ts
6. ModelStore.initContext() calls hasEnoughMemory() at line 1031

Android API Research (Updated):
- Initially planned to use /proc/meminfo (Linux kernel interface)
- After research, switched to ActivityManager.getMemoryInfo() because:
  * Official Android API - works reliably across all devices
  * No SELinux permission issues on newer Android or OEM ROMs
  * Abstracts kernel differences (MemAvailable added in Linux 3.14)
  * Same data: availMem equals MemFree + Cached from /proc/meminfo
  * Sources: developer.android.com/reference/android/app/ActivityManager.MemoryInfo

Key files researched:
- android/app/src/main/java/com/pocketpalai/HardwareInfoModule.kt (198 lines)
- ios/PocketPal/HardwareInfoModule.mm (63 lines)
- src/specs/NativeHardwareInfo.ts (40 lines)
- src/hooks/useMemoryCheck.ts (74 lines)
- jest/setup.ts (mocking patterns)

Implementation approach:
1. Add native methods (Android: ActivityManager, iOS: os_proc_available_memory)
2. Update TurboModule spec
3. Update JS logic with fallback
4. Update test mocks
5. Platform builds verification

Risks: Minimal - fallback to heuristic ensures no regression. Safety margin prevents over-estimation.

Story complexity: Standard (requires native code + tests)
```

### Implementation Report
```
Date: 2026-01-26
Agent: pocketpal-implementer

Environment:
- Task ID: TASK-20260126-1433
- Worktree: /Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260126-1433
- Branch: feature/TASK-20260126-1433

Story: Fix Memory Estimation for Model Loading by Adding Native getAvailableMemory() API

Status: COMPLETE

Changes Made:

| File | Change | Commit |
|------|--------|--------|
| android/app/.../HardwareInfoModule.kt | Added getAvailableMemory() using ActivityManager | a4e3e41 |
| ios/PocketPal/HardwareInfoModule.mm | Added getAvailableMemory() using os_proc_available_memory() | 85f65e4 |
| src/specs/NativeHardwareInfo.ts | Added getAvailableMemory() to Spec interface | 044dd9a |
| src/hooks/useMemoryCheck.ts | Updated to use native API with 10% margin + fallback | 3067109 |
| jest/setup.ts | Added getAvailableMemory mock (3GB) | d249574 |
| jest/fixtures/device-info.ts | Added availableMemory: 3GB | d249574 |
| ios/PocketPal/HardwareInfoModule.mm | Fixed header to use <os/proc.h> | 5016e1b |

Implementation Details:
1. Android: Uses ActivityManager.getMemoryInfo().availMem - official API, no permission issues
2. iOS: Uses os_proc_available_memory() from <os/proc.h> header
3. JavaScript: Applies 10% safety margin, falls back to heuristic on error
4. Debug logging added to compare actual vs heuristic in __DEV__ mode
5. All existing tests pass with updated mocks

Deviations from Plan:
- Android: Used ActivityManager.getMemoryInfo() instead of /proc/meminfo
  Reason: Official API, more reliable, no SELinux permission issues on newer Android
- iOS: Fixed header from <sys/sysctl.h> to <os/proc.h>
  Reason: os_proc_available_memory() requires <os/proc.h>
- Mock memory: Increased from 2.5GB to 3GB
  Reason: After 10% margin (2.7GB), needed to fit 2GB test model (requires 2.27GB)

Verification Results:
- Lint: PASS (only pre-existing warnings in other files)
- TypeCheck: PASS
- Tests: PASS (3/3 tests in useMemoryCheck.test.ts)
- Pod Install: PASS (no Podfile.lock changes)
- iOS Build: PASS (Release configuration, iphonesimulator)
- Android Build: PASS (assembleRelease)

Notes for Tester:
- New tests needed for:
  1. Native API returns correct value
  2. Fallback works when native API fails
  3. 10% safety margin is applied correctly
- Mock is configured at 3GB available memory
- NativeHardwareInfo.getAvailableMemory is mocked in jest/setup.ts
- Test pattern should follow existing useMemoryCheck tests

Blockers: None
```

### Test Report
```
[Filled by tester after tests written]
```

### Review Report
```
[Filled by reviewer after review]
```

---

## Changelog

| Date | Agent/Human | Change |
|------|-------------|--------|
| 2026-01-26 | orchestrator | Created worktree and task |
| 2026-01-26 | planner | Initial story draft with detailed research |
