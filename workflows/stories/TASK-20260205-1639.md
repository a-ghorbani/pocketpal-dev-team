# Story: Fix HuggingFace Model File Storage Paths

## Metadata
- **Task ID**: TASK-20260205-1639
- **Issue**: #558
- **Source**: github
- **Complexity**: standard
- **Native Changes**: NO
- **Created**: 2026-02-05T16:39:00Z
- **Status**: draft

## Environment
- **Worktree**: `/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639`
- **Branch**: `feature/TASK-20260205-1639`
- **Base**: `main`

---

## Progress Tracking

### Current Phase
`[X] Planning → [ ] Approved → [ ] Implementing → [ ] Testing → [ ] Reviewing → [ ] PR Created`

### Checkpoints (Updated by Agents)

| Checkpoint | Status | Agent | Commit | Notes |
|------------|--------|-------|--------|-------|
| Worktree created | DONE | orchestrator | - | |
| Story created | DONE | planner | - | |
| Story revised | DONE | planner | - | Added `repo` field approach per human feedback |
| Story approved | PENDING | human | - | |
| Step 1 complete | PENDING | implementer | - | Add `repo` to Model type |
| Step 2 complete | PENDING | implementer | - | Add `repo` to preset models + increment version |
| Step 3 complete | PENDING | implementer | - | Set `repo` in hfAsModel() |
| Step 4 complete | PENDING | implementer | - | Update getModelFullPath() |
| Step 5 complete | PENDING | implementer | - | Update Swift implementation |
| Tests written | PENDING | tester | - | |
| Review passed | PENDING | reviewer | - | |
| PR created | PENDING | reviewer | - | |

### Last Agent Handoff
```yaml
from_agent: planner
to_agent: human
timestamp: 2026-02-05T17:00:00Z
status: "Story revised with repo field approach, awaiting approval"
completed:
  - Researched ModelStore.ts getModelFullPath() implementation
  - Researched PalDataProvider.swift parseModelPath() implementation
  - Researched preset models and reset functionality
  - Analyzed mergeModelLists() and Object.assign() behavior
  - Identified all affected files for repo field approach
next_steps:
  - Human review and approve story
  - Then route to implementer
blockers: []
context_for_next_agent: |
  REVISED APPROACH: Add explicit `repo` field to Model type instead of parsing from model.id

  Key points:
  - Add `repo?: string` to Model type in types.ts
  - Add `repo` to all preset models in defaultModels.ts
  - Extract and set `repo` in hfAsModel() when downloading HF models
  - Increment MODEL_LIST_VERSION to 14 to trigger mergeModelLists()
  - Use model.repo in getModelFullPath() with backwards compatibility
  - mergeModelLists() uses Object.assign() which will auto-merge new `repo` field

  Critical edge case handled:
  - User has downloaded preset model (file at old path)
  - App updates, preset now has `repo` field
  - User triggers reset → model object gets rebuilt with `repo`
  - But file is still at old path!
  - Solution: Always check old path first in getModelFullPath()
```

---

## Context (For Recovery After Context Reset)

> **If you're an agent resuming work on this story:**
> 1. Read the "Progress Tracking" section above
> 2. Check `git log` in the worktree for commits
> 3. Read the "Last Agent Handoff" section
> 4. Continue from the next incomplete checkpoint

### Background
HuggingFace model files are currently stored with a flat directory structure under the author directory, which can cause collisions when different repositories from the same author have files with the same name. The path structure should include the repository name to ensure uniqueness.

**From GitHub Issue #558:**
- Model files are stored at `models/hf/{author}/{filename}`
- This is missing the repository name level
- Can cause collisions if the same author has multiple repos with same-named files
- Expected path structure: `models/hf/{author}/{repo-name}/{filename}`

### Current State

**TypeScript Implementation** (`src/store/ModelStore.ts` lines 729-733):
```typescript
// For HF models, use author/model structure
if (model.origin === ModelOrigin.HF) {
  const author = model.author || 'unknown';
  return `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${model.filename}`;
}
```

**Swift Implementation** (`ios/PocketPal/AppIntents/PalDataProvider.swift` lines 219-224):
```swift
// For HF models, use author/model structure
if origin == "hf" {
    let author = dict["author"] as? String ?? "unknown"
    let path = documentsPath.appendingPathComponent("models/hf/\(author)/\(filename)").path
    print("[PalDataProvider] Constructed HF model path: \(path)")
    return path
}
```

**Model ID Structure** (`src/utils/index.ts` line 451):
HF model IDs are constructed as: `hfModel.id + '/' + modelFile.rfilename`
- `hfModel.id` = repository ID in format `author/repo-name`
- `modelFile.rfilename` = filename like `model.gguf`
- Full model ID example: `MaziyarPanahi/gemma-3-1b-it-GGUF/gemma-3-1b-it.Q8_0.gguf`

### Target State
After this change:
1. **Model type** has explicit `repo` field
2. **Preset models** have `repo` field populated
3. **New HF downloads** get `repo` set from `hfModel.id`
4. **Path construction** uses `model.repo` with backwards compatibility
5. Both TypeScript and Swift implementations use the same logic

---

## Requirements

### Functional
1. [MUST] Add `repo?: string` field to Model type
2. [MUST] Add `repo` field to all preset model definitions in defaultModels.ts
3. [MUST] Extract and set `repo` from `hfModel.id` in `hfAsModel()` when downloading HF models
4. [MUST] Increment `MODEL_LIST_VERSION` to 14 to trigger `mergeModelLists()`
5. [MUST] Update `getModelFullPath()` to use `model.repo` with backwards compatibility
6. [MUST] Update Swift `parseModelPath()` to use `repo` field from dict
7. [MUST] Support backwards compatibility - check old path first before using new path

### Non-Functional
- Performance: No significant impact (one additional path check for backwards compatibility)
- Compatibility: Must work with existing downloaded models
- Security: No security implications

### Migration Considerations
- [X] Does this change affect stored user data/settings? YES - affects model file storage paths
- [X] Is backwards compatibility needed for existing users? YES - users have already downloaded models
- Migration strategy: `support both paths` - check old path first, use new path for new downloads
- Files/paths affected: All HF model files in `models/hf/{author}/` directories
- Notes: `mergeModelLists()` uses `Object.assign()` which will automatically add `repo` field to existing persisted models on app update. Backwards compat check handles file location mismatch.

### Edge Cases Handled
| Scenario | Model Object | File Location | Solution |
|----------|--------------|---------------|----------|
| Existing HF model (before update) | No `repo` field | Old path | Backwards compat check finds file |
| Existing HF model (after update) | Gets `repo` via merge | Old path | Backwards compat check finds file |
| New HF download | Has `repo` field | New path | Uses new path structure |
| Downloaded preset (before update) | No `repo` field | Old path | Backwards compat check finds file |
| Downloaded preset (after update) | Gets `repo` via merge | Old path | Backwards compat check finds file |
| After reset | Gets `repo` from preset | Old path | Backwards compat check finds file |

---

## Acceptance Criteria

- [ ] Model type has `repo?: string` field
- [ ] All preset models have `repo` field populated
- [ ] `hfAsModel()` extracts and sets `repo` from HuggingFace model ID
- [ ] `MODEL_LIST_VERSION` incremented to 14
- [ ] HF model paths include repository name: `models/hf/{author}/{repo}/{filename}`
- [ ] Backwards compatibility works - existing models at old paths still load
- [ ] TypeScript and Swift implementations produce identical paths
- [ ] All existing tests pass
- [ ] New tests added for `repo` field handling
- [ ] Coverage >= 60%

---

## Affected Files

| File | Action | Reason | Status |
|------|--------|--------|--------|
| `src/utils/types.ts` | MODIFY | Add `repo?: string` to Model type | PENDING |
| `src/store/defaultModels.ts` | MODIFY | Add `repo` to all preset models + increment version | PENDING |
| `src/utils/index.ts` | MODIFY | Extract `repo` in `hfAsModel()` | PENDING |
| `src/store/ModelStore.ts` | MODIFY | Update `getModelFullPath()` to use `model.repo` with backwards compat | PENDING |
| `ios/PocketPal/AppIntents/PalDataProvider.swift` | MODIFY | Update `parseModelPath()` to use `repo` from dict | PENDING |
| `src/store/__tests__/ModelStore.test.ts` | MODIFY | Add tests for `repo` field and path construction | PENDING |

---

## Implementation Plan

### Step 1: Add `repo` field to Model type
**Files**: `src/utils/types.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Add `repo?: string` field to the Model interface

**Code Guidance**:
Find the Model interface (around line 355-398) and add the `repo` field near `author`:
```typescript
export interface Model {
  // ... existing fields
  author?: string;
  repo?: string;  // ← NEW: Repository name (e.g., "gemma-3-1b-it-GGUF")
  // ... rest of fields
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
```

### Step 2: Add `repo` to preset models and increment version
**Files**: `src/store/defaultModels.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Increment `MODEL_LIST_VERSION` from 13 to 14 (line 6)
- [ ] Add `repo` field to all preset model definitions

**Code Guidance**:
```typescript
// Line 6 - increment version
export const MODEL_LIST_VERSION = 14;  // was 13

// For each preset model, extract repo from the id
// Example: id = 'bartowski/gemma-2-2b-it-GGUF/gemma-2-2b-it-Q6_K.gguf'
// → repo = 'gemma-2-2b-it-GGUF'

{
  id: 'bartowski/gemma-2-2b-it-GGUF/gemma-2-2b-it-Q6_K.gguf',
  author: 'bartowski',
  repo: 'gemma-2-2b-it-GGUF',  // ← NEW
  // ... rest of model definition
}
```

**Pattern**: Extract repo by splitting id on `/` and taking parts[1]:
- `id.split('/')[0]` = author (e.g., "bartowski")
- `id.split('/')[1]` = repo (e.g., "gemma-2-2b-it-GGUF")
- `id.split('/')[2]` = filename (e.g., "gemma-2-2b-it-Q6_K.gguf")

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
```

### Step 3: Set `repo` in hfAsModel() for HF downloads
**Files**: `src/utils/index.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Extract `repo` from `hfModel.id` and include in returned Model object

**Code Guidance**:
In `hfAsModel()` function (lines 405-491):
```typescript
export function hfAsModel(
  hfModel: HuggingFaceModel,
  modelFile: ModelFile,
): Model {
  // Extract repo from hfModel.id (format: "author/repo-name")
  const repoParts = hfModel.id.split('/');
  const repo = repoParts.length >= 2 ? repoParts[1] : undefined;

  const _model: Model = {
    id: hfModel.id + '/' + modelFile.rfilename,
    type: extractHFModelType(hfModel.id),
    author: hfModel.author,
    repo: repo,  // ← NEW
    name: extractHFModelTitle(modelFile.rfilename),
    // ... rest of model definition
  };

  return _model;
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
```

### Step 4: Update getModelFullPath() to use model.repo
**Files**: `src/store/ModelStore.ts`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Update HF model path construction to use `model.repo`
- [ ] Implement backwards compatibility (check old path first)

**Code Guidance**:
Replace lines 729-733:
```typescript
// For HF models, use author/repo/model structure with backwards compatibility
if (model.origin === ModelOrigin.HF) {
  const author = model.author || 'unknown';
  const repo = model.repo || 'unknown';

  // Old path structure (for backwards compatibility)
  const oldPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${model.filename}`;

  // New path structure includes repository name
  const newPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${repo}/${model.filename}`;

  // Check if file exists at old path (backwards compatibility)
  // This handles: existing downloads, models after reset, models after app update
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old HF model path:', err);
  }

  // Otherwise use new path
  return newPath;
}
```

**Pattern Reference**: See `src/store/ModelStore.ts:710-727` for preset models backwards compatibility pattern

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
yarn test --findRelatedTests src/store/ModelStore.ts
```

### Step 5: Update Swift parseModelPath() to use repo
**Files**: `ios/PocketPal/AppIntents/PalDataProvider.swift`
**Status**: `PENDING`
**Commit**: [commit hash when done]

**Change**:
- [ ] Extract `repo` from dict
- [ ] Implement backwards compatibility (matching TypeScript logic)

**Code Guidance**:
Replace lines 219-224:
```swift
// For HF models, use author/repo/model structure with backwards compatibility
if origin == "hf" {
    let author = dict["author"] as? String ?? "unknown"
    let repo = dict["repo"] as? String ?? "unknown"

    // Old path structure (for backwards compatibility)
    let oldPath = documentsPath.appendingPathComponent("models/hf/\(author)/\(filename)").path

    // New path structure includes repository name
    let newPath = documentsPath.appendingPathComponent("models/hf/\(author)/\(repo)/\(filename)").path

    // Check if file exists at old path (backwards compatibility)
    if fileManager.fileExists(atPath: oldPath) {
        print("[PalDataProvider] Found HF model at old path: \(oldPath)")
        return oldPath
    }

    // Otherwise use new path
    print("[PalDataProvider] Using new HF model path: \(newPath)")
    return newPath
}
```

**Pattern Reference**: See `ios/PocketPal/AppIntents/PalDataProvider.swift:202-216` for preset models Swift implementation

**Verification**:
```bash
cd "${WORKTREE_PATH}"
# Swift compilation verified during iOS build in review phase
```

---

## Test Requirements

### Unit Tests
| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| New HF path includes repository name | `ModelStore.test.ts` | MUST | PENDING |
| Backwards compat - old path preferred if exists | `ModelStore.test.ts` | MUST | PENDING |
| Uses model.repo field for path | `ModelStore.test.ts` | MUST | PENDING |
| Fallback to 'unknown' if repo missing | `ModelStore.test.ts` | MUST | PENDING |
| Error handling when checking old path | `ModelStore.test.ts` | SHOULD | PENDING |
| hfAsModel sets repo correctly | `index.test.ts` or `ModelStore.test.ts` | MUST | PENDING |

### Test Code Guidance
```typescript
describe('getModelFullPath - HF models with repo field', () => {
  it('should construct new path with repo for HF model', async () => {
    const hfModel = {
      id: 'test-author/test-repo/model.gguf',
      origin: ModelOrigin.HF,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock old path doesn't exist
    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(hfModel as any);
    expect(path).toContain('/models/hf/test-author/test-repo/model.gguf');
  });

  it('should use old path if file exists there (backwards compatibility)', async () => {
    const hfModel = {
      id: 'test-author/test-repo/model.gguf',
      origin: ModelOrigin.HF,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock old path exists
    (RNFS.exists as jest.Mock).mockResolvedValue(true);

    const path = await modelStore.getModelFullPath(hfModel as any);
    expect(path).toContain('/models/hf/test-author/model.gguf');
    expect(path).not.toContain('/test-repo/');
  });

  it('should fallback to unknown if repo field missing', async () => {
    const hfModel = {
      id: 'test-author/test-repo/model.gguf',
      origin: ModelOrigin.HF,
      filename: 'model.gguf',
      author: 'test-author',
      // repo field intentionally missing
    };

    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(hfModel as any);
    expect(path).toContain('/models/hf/test-author/unknown/model.gguf');
  });

  it('should handle error when checking old path', async () => {
    const hfModel = {
      id: 'test-author/test-repo/model.gguf',
      origin: ModelOrigin.HF,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    (RNFS.exists as jest.Mock).mockRejectedValue(new Error('File system error'));

    const path = await modelStore.getModelFullPath(hfModel as any);
    // Should still return new path despite error
    expect(path).toContain('/models/hf/test-author/test-repo/model.gguf');
  });
});
```

### Manual Testing
- [ ] Download a new HF model and verify it goes to new path structure
- [ ] Verify existing downloaded HF models still work (old path)
- [ ] Test reset functionality - model should still work after reset
- [ ] Check that multimodal models (with projection models) work correctly

---

## Coding Standards

### Testing Infrastructure (CRITICAL)
```
# Read these BEFORE writing tests:
/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639/jest/setup.ts      # Global mocks
/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639/jest/test-utils.tsx # Custom render
/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639/__mocks__/stores/  # Mock stores

# DO NOT mock stores inline - they're globally mocked
# Use runInAction() for MobX state changes
# Import render from jest/test-utils, NOT @testing-library/react-native
```

### Patterns to Follow
- **State**: Use MobX `@observable`, `@action`, `@computed`
- **Async Actions**: Use `runInAction()` for state updates after async operations
- **Error Handling**: Use try-catch, log errors, gracefully fallback
- **Testing**: Follow existing test patterns in ModelStore.test.ts

### Commit Format (enforced by commitlint)
```
type(scope): subject
```

**Rules**:
- Header max: 100 chars total
- Types allowed: `feat`, `fix`, `docs`, `chore` (only these 4)
- No Co-Authored-By needed
- Keep it short and clear

**Examples**:
```
fix(model): add repo field to Model type for HF storage paths
fix(model): add repo to preset models and increment version
fix(model): set repo in hfAsModel for HF downloads
fix(model): use model.repo in getModelFullPath with backwards compat
fix(ios): update Swift parseModelPath to use repo field
```

### Naming Conventions
- Variables: camelCase (`repo`, `oldPath`, `newPath`)
- Constants: UPPER_SNAKE_CASE if truly constant
- Functions: camelCase (`getModelFullPath`)

---

## Reference Code

### Pattern Example: Preset Models Backwards Compatibility
**File**: `src/store/ModelStore.ts`
**Lines**: 710-727
```typescript
// For preset models, check both old and new paths
if (model.origin === ModelOrigin.PRESET) {
  const author = model.author || 'unknown';
  const oldPath = `${RNFS.DocumentDirectoryPath}/${model.filename}`; // old path is deprecated
  const newPath = `${RNFS.DocumentDirectoryPath}/models/preset/${author}/${model.filename}`;

  // If the file exists in old path, use that (for backwards compatibility)
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old path:', err);
  }

  // Otherwise use new path
  return newPath;
}
```

### Pattern Example: mergeModelLists() Object.assign behavior
**File**: `src/store/ModelStore.ts`
**Lines**: 520-531
```typescript
// This merges any NEW fields from defaultModel into existing model
const {
  id, defaultChatTemplate, defaultStopWords, chatTemplate, stopWords,
  ...attributesToMerge
} = defaultModel;

Object.assign(existingModel, attributesToMerge);
// ^ This will add `repo` field to existing persisted models on version change
```

### Pattern Example: hfAsModel structure
**File**: `src/utils/index.ts`
**Lines**: 405-491
```typescript
export function hfAsModel(
  hfModel: HuggingFaceModel,
  modelFile: ModelFile,
): Model {
  const _model: Model = {
    id: hfModel.id + '/' + modelFile.rfilename,
    type: extractHFModelType(hfModel.id),
    author: hfModel.author,
    // repo: extracted from hfModel.id ← ADD THIS
    name: extractHFModelTitle(modelFile.rfilename),
    // ...
  };
  return _model;
}
```

---

## Dependencies

### Blocked By
- None

### Blocks
- None

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| TypeScript and Swift implementations diverge | Medium | High | Add explicit comment in both files referencing each other |
| Preset models missing `repo` field | Low | Medium | Systematic update of all presets, typecheck will catch missing fields if type is strict |
| Existing models become inaccessible | Low | High | Backwards compatibility check ensures old paths work |
| Reset breaks model access | Low | High | Backwards compat handles file location mismatch after reset |
| `mergeModelLists()` doesn't merge `repo` | Low | Medium | `Object.assign()` includes all fields not explicitly excluded |

---

## Open Questions

### For Human
- None

### Resolved
- **Q**: Should we parse `repo` from `model.id` or add explicit field?
- **A**: Add explicit `repo` field - cleaner, follows `author` pattern, set once during download/preset definition

---

## Agent Reports

### Planner Report
```
Research completed on 2026-02-05T17:00:00Z

REVISION: Updated approach per human feedback

Original approach: Parse repo from model.id string
Revised approach: Add explicit `repo` field to Model type

Key Findings:
1. Preset models defined in defaultModels.ts with MODEL_LIST_VERSION tracking
2. resetModels() wipes and rebuilds from defaultModels via mergeModelLists()
3. mergeModelLists() uses Object.assign() - will auto-merge new `repo` field
4. Edge case: After reset/update, model has `repo` but file at old path
5. Solution: Always check old path first (backwards compatibility pattern)

Files affected: 6 files
- types.ts (add repo field)
- defaultModels.ts (add repo to presets, increment version)
- utils/index.ts (set repo in hfAsModel)
- ModelStore.ts (use model.repo in getModelFullPath)
- PalDataProvider.swift (use repo from dict)
- ModelStore.test.ts (tests)

Complexity justified by: Cross-platform sync + backwards compatibility + multiple edge cases
```

### Implementation Report
```
[Filled by implementer after code complete]
```

### Test Report
```
[Filled by tester after tests written]
```

### Review Report
```
[Filled by reviewer after review]
```

---

## Changelog

| Date | Agent/Human | Change |
|------|-------------|--------|
| 2026-02-05 | orchestrator | Created worktree and task |
| 2026-02-05 | planner | Initial story draft |
| 2026-02-05 | human | Requested revision: use explicit `repo` field instead of parsing |
| 2026-02-05 | planner | Revised story with `repo` field approach |
