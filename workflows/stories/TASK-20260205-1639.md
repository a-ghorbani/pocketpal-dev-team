# Story: Fix HuggingFace Model File Storage Paths

## Metadata
- **Task ID**: TASK-20260205-1639
- **Issue**: #558
- **Source**: github
- **Complexity**: standard
- **Native Changes**: NO
- **Created**: 2026-02-05T16:39:00Z
- **Status**: iteration-2

## Environment
- **Worktree**: `/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639`
- **Branch**: `feature/TASK-20260205-1639`
- **Base**: `main`

---

## Progress Tracking

### Current Phase
`[X] Planning → [X] Approved → [X] Implementing → [ ] Testing → [ ] Reviewing → [ ] PR Created`

### Checkpoints (Updated by Agents)

| Checkpoint | Status | Agent | Commit | Notes |
|------------|--------|-------|--------|-------|
| Worktree created | DONE | orchestrator | - | |
| Story created | DONE | planner | - | |
| Story revised | DONE | planner | - | Added `repo` field approach per human feedback |
| Story approved | DONE | human | - | Implementation proceeded |
| Step 1 complete | DONE | implementer | 670ccc9 | Add `repo` to Model type |
| Step 2 complete | DONE | implementer | 936363a | Add `repo` to preset models + increment version |
| Step 3 complete | DONE | implementer | f351c97 | Set `repo` in hfAsModel() |
| Step 4 complete | DONE | implementer | 0084e65 | Update getModelFullPath() for HF models |
| Step 5 complete | DONE | implementer | 9a669fb | Update Swift implementation for HF models |
| Tests written | DONE | tester | c9ff6b0 | 9 new tests, all passing |
| PR created | DONE | reviewer | - | Draft PR #559 |
| **Iteration 2** | | | | **Add repo to preset paths for consistency** |
| Story revised (iter 2) | DONE | planner | - | Add repo to preset model paths |
| Step 6 complete | DONE | implementer | bc39e6e | Update preset path in getModelFullPath() |
| Step 7 complete | DONE | implementer | 6aa40b8 | Update preset path in Swift |
| Step 8 complete | DONE | tester | 603a1b1 | 6 tests for preset paths |
| Review passed | DONE | reviewer | - | Approved |
| PR updated | DONE | reviewer | - | PR #559 ready for review |
| **Iteration 3** | | | | **Infer repo from model.id for existing HF models** |
| Story revised (iter 3) | DONE | planner | - | Plan repo inference for existing HF models |
| Step 9 complete | DONE | implementer | fff6154 | Add inferRepoFromModelId() utility |
| Step 10 complete | DONE | implementer | 8ac9d8e | Enhance path fallback with repo inference |
| Tests written | TODO | tester | - | Add tests for repo inference |
| Review passed | TODO | reviewer | - | |
| PR updated | PENDING | reviewer | - | |

### Last Agent Handoff
```yaml
from_agent: implementer
to_agent: tester
timestamp: 2026-02-06T16:30:00Z
status: "Steps 9-10 complete, ready for tests"
completed:
  - Step 9: Added inferRepoFromModelId() utility function (commit fff6154)
  - Step 9: Updated mergeModelLists() to infer repo for HF models without repo field
  - Step 10: Enhanced getModelFullPath() to use repo inference as fallback (commit 8ac9d8e)
  - Step 10: Added Swift helper and updated parseModelPath() with same logic
  - Fixed null/undefined guard in inferRepoFromModelId()
  - Verified lint and typecheck pass
  - Pre-existing test failure unrelated to changes
next_steps:
  - Write unit tests for inferRepoFromModelId() utility
  - Write integration tests for repo inference in mergeModelLists()
  - Write integration tests for repo inference fallback in getModelFullPath()
  - Verify preset models are not affected
  - Ensure all new tests pass
blockers: []
context_for_next_agent: |
  Implementation complete for Steps 9-10. The code is ready for testing.

  APPROACH TAKEN (Option C - Belt and Suspenders):
  - Primary fix: mergeModelLists() infers repo for HF models at startup
  - Fallback: getModelFullPath() infers repo if missing at runtime
  - Both TypeScript and Swift implementations mirror each other

  KEY IMPLEMENTATION DETAILS:
  1. inferRepoFromModelId() utility:
     - Parses HF model ID format: "author/repo/filename"
     - Returns repo name (2nd part) or undefined
     - Handles null/undefined/malformed inputs gracefully

  2. mergeModelLists() integration (TypeScript):
     - After line 570, added inference for HF models
     - Only sets repo if missing (idempotent)
     - Logs when inference happens
     - Explicitly checks origin === ModelOrigin.HF

  3. getModelFullPath() fallback (TypeScript):
     - Line 748-751 updated
     - Try model.repo → infer from model.id → fallback to 'unknown'

  4. Swift mirror implementation:
     - Added inferRepoFromModelId() helper before parseModelPath()
     - Updated HF section in parseModelPath()
     - Same logic: try dict["repo"] → infer → fallback

  TESTING GUIDANCE:
  - See Step 11 in story file for test scenarios and code examples
  - Focus on utility function, startup inference, and runtime fallback
  - Verify preset models unchanged
  - Test malformed/edge case model IDs

  FILES MODIFIED:
  - src/utils/index.ts (utility function)
  - src/store/ModelStore.ts (mergeModelLists + getModelFullPath)
  - ios/PocketPal/AppIntents/PalDataProvider.swift (Swift helpers)
```

---

## Context (For Recovery After Context Reset)

> **If you're an agent resuming work on this story:**
> 1. Read the "Progress Tracking" section above
> 2. Check `git log` in the worktree for commits
> 3. Read the "Last Agent Handoff" section
> 4. Continue from the next incomplete checkpoint

### Background
HuggingFace model files are currently stored with a flat directory structure under the author directory, which can cause collisions when different repositories from the same author have files with the same name. The path structure should include the repository name to ensure uniqueness.

**From GitHub Issue #558:**
- Model files are stored at `models/hf/{author}/{filename}`
- This is missing the repository name level
- Can cause collisions if the same author has multiple repos with same-named files
- Expected path structure: `models/hf/{author}/{repo-name}/{filename}`

**Iteration 2 Context:**
- After implementing HF models with repo in path, human testing revealed preset models don't use repo in their path
- For consistency, preset models should also use: `models/preset/{author}/{repo}/{filename}`
- This creates a single pattern across both HF and PRESET origins

### Current State

**TypeScript Implementation - PRESET** (`src/store/ModelStore.ts` lines 712-727):
```typescript
// For preset models, check both old and new paths
if (model.origin === ModelOrigin.PRESET) {
  const author = model.author || 'unknown';
  const oldPath = `${RNFS.DocumentDirectoryPath}/${model.filename}`;
  const newPath = `${RNFS.DocumentDirectoryPath}/models/preset/${author}/${model.filename}`;
  
  // Check old path first
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old path:', err);
  }
  
  return newPath;
}
```

**Swift Implementation - PRESET** (`ios/PocketPal/AppIntents/PalDataProvider.swift` lines 202-216):
```swift
// For preset models, check both old and new paths
if origin == "preset" {
    let author = dict["author"] as? String ?? "unknown"
    let oldPath = documentsPath.appendingPathComponent(filename).path
    let newPath = documentsPath.appendingPathComponent("models/preset/\(author)/\(filename)").path
    
    // If the file exists in old path, use that (for backwards compatibility)
    if fileManager.fileExists(atPath: oldPath) {
        print("[PalDataProvider] Found model at old path")
        return oldPath
    }
    
    // Otherwise use new path
    return newPath
}
```

**Model Structure** (`src/store/defaultModels.ts`):
- All preset models already have `repo` field (added in Iteration 1)
- Example: `{ author: 'bartowski', repo: 'gemma-2-2b-it-GGUF', ... }`

### Target State
After Iteration 2:
1. **PRESET models** use `models/preset/{author}/{repo}/{filename}` path
2. **HF models** use `models/hf/{author}/{repo}/{filename}` path
3. **Backwards compatibility** supports THREE old paths for presets:
   - Very old: `/{filename}`
   - Old: `/models/preset/{author}/{filename}`
   - New: `/models/preset/{author}/{repo}/{filename}`
4. Both TypeScript and Swift implementations use identical logic

---

## Requirements

### Functional
1. [DONE] Add `repo?: string` field to Model type
2. [DONE] Add `repo` field to all preset model definitions in defaultModels.ts
3. [DONE] Extract and set `repo` from `hfModel.id` in `hfAsModel()` when downloading HF models
4. [DONE] Increment `MODEL_LIST_VERSION` to 14 to trigger `mergeModelLists()`
5. [DONE] Update `getModelFullPath()` to use `model.repo` for HF models with backwards compatibility
6. [DONE] Update Swift `parseModelPath()` to use `repo` field from dict for HF models
7. [NEW] Update `getModelFullPath()` to use `model.repo` for PRESET models with backwards compatibility
8. [NEW] Update Swift `parseModelPath()` to use `repo` field from dict for PRESET models
9. [NEW] Add tests for preset paths with repo field

### Non-Functional
- Performance: No significant impact (one additional path check for backwards compatibility)
- Compatibility: Must work with existing downloaded models
- Security: No security implications

### Migration Considerations
- [X] Does this change affect stored user data/settings? YES - affects model file storage paths
- [X] Is backwards compatibility needed for existing users? YES - users have already downloaded models
- Migration strategy: `support multiple paths` - check old paths first, use new path for new downloads
- Files/paths affected: All PRESET and HF model files
- Notes: `mergeModelLists()` uses `Object.assign()` which will automatically add `repo` field to existing persisted models on app update. Backwards compat checks handle file location mismatch.

### Edge Cases Handled
| Scenario | Model Object | File Location | Solution |
|----------|--------------|---------------|----------|
| Existing HF model (before update) | No `repo` field | Old path | Backwards compat check finds file |
| Existing HF model (after update) | Gets `repo` via merge | Old path | Backwards compat check finds file |
| New HF download | Has `repo` field | New path | Uses new path structure |
| Downloaded preset (very old) | Gets `repo` via merge | Very old path | Backwards compat finds file |
| Downloaded preset (old) | Gets `repo` via merge | Old path | Backwards compat finds file |
| Downloaded preset (after update) | Has `repo` field | Old path | Backwards compat finds file |
| After reset | Gets `repo` from preset | Old path | Backwards compat finds file |
| New preset download | Has `repo` field | New path | Uses new path structure |

---

## Acceptance Criteria

- [X] Model type has `repo?: string` field
- [X] All preset models have `repo` field populated
- [X] `hfAsModel()` extracts and sets `repo` from HuggingFace model ID
- [X] `MODEL_LIST_VERSION` incremented to 14
- [X] HF model paths include repository name: `models/hf/{author}/{repo}/{filename}`
- [X] HF backwards compatibility works - existing models at old paths still load
- [ ] PRESET model paths include repository name: `models/preset/{author}/{repo}/{filename}`
- [ ] PRESET backwards compatibility works - existing models at old paths (both very old and old) still load
- [ ] TypeScript and Swift implementations produce identical paths for both HF and PRESET
- [ ] All existing tests pass
- [ ] New tests added for preset `repo` field handling
- [ ] Coverage >= 60%

---

## Affected Files

| File | Action | Reason | Status |
|------|--------|--------|--------|
| `src/utils/types.ts` | MODIFY | Add `repo?: string` to Model type | DONE |
| `src/store/defaultModels.ts` | MODIFY | Add `repo` to all preset models + increment version | DONE |
| `src/utils/index.ts` | MODIFY | Extract `repo` in `hfAsModel()` | DONE |
| `src/store/ModelStore.ts` | MODIFY | Update `getModelFullPath()` for HF and PRESET origins | PARTIAL (HF done, PRESET pending) |
| `ios/PocketPal/AppIntents/PalDataProvider.swift` | MODIFY | Update `parseModelPath()` for HF and PRESET origins | PARTIAL (HF done, PRESET pending) |
| `src/store/__tests__/ModelStore.test.ts` | MODIFY | Add tests for HF and PRESET paths | PARTIAL (HF done, PRESET pending) |

---

## Implementation Plan

### Step 1: Add `repo` field to Model type
**Files**: `src/utils/types.ts`
**Status**: `DONE`
**Commit**: 670ccc9

**Change**:
- [X] Add `repo?: string` field to the Model interface

**Code Guidance**:
Find the Model interface (around line 355-398) and add the `repo` field near `author`:
```typescript
export interface Model {
  // ... existing fields
  author?: string;
  repo?: string;  // ← NEW: Repository name (e.g., "gemma-3-1b-it-GGUF")
  // ... rest of fields
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
```

### Step 2: Add `repo` to preset models and increment version
**Files**: `src/store/defaultModels.ts`
**Status**: `DONE`
**Commit**: 936363a

**Change**:
- [X] Increment `MODEL_LIST_VERSION` from 13 to 14 (line 6)
- [X] Add `repo` field to all preset model definitions

**Code Guidance**:
```typescript
// Line 6 - increment version
export const MODEL_LIST_VERSION = 14;  // was 13

// For each preset model, extract repo from the id
// Example: id = 'bartowski/gemma-2-2b-it-GGUF/gemma-2-2b-it-Q6_K.gguf'
// → repo = 'gemma-2-2b-it-GGUF'

{
  id: 'bartowski/gemma-2-2b-it-GGUF/gemma-2-2b-it-Q6_K.gguf',
  author: 'bartowski',
  repo: 'gemma-2-2b-it-GGUF',  // ← NEW
  // ... rest of model definition
}
```

**Pattern**: Extract repo by splitting id on `/` and taking parts[1]:
- `id.split('/')[0]` = author (e.g., "bartowski")
- `id.split('/')[1]` = repo (e.g., "gemma-2-2b-it-GGUF")
- `id.split('/')[2]` = filename (e.g., "gemma-2-2b-it-Q6_K.gguf")

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
```

### Step 3: Set `repo` in hfAsModel() for HF downloads
**Files**: `src/utils/index.ts`
**Status**: `DONE`
**Commit**: f351c97

**Change**:
- [X] Extract `repo` from `hfModel.id` and include in returned Model object

**Code Guidance**:
In `hfAsModel()` function (lines 405-491):
```typescript
export function hfAsModel(
  hfModel: HuggingFaceModel,
  modelFile: ModelFile,
): Model {
  // Extract repo from hfModel.id (format: "author/repo-name")
  const repoParts = hfModel.id.split('/');
  const repo = repoParts.length >= 2 ? repoParts[1] : undefined;

  const _model: Model = {
    id: hfModel.id + '/' + modelFile.rfilename,
    type: extractHFModelType(hfModel.id),
    author: hfModel.author,
    repo: repo,  // ← NEW
    name: extractHFModelTitle(modelFile.rfilename),
    // ... rest of model definition
  };

  return _model;
}
```

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
```

### Step 4: Update getModelFullPath() for HF models
**Files**: `src/store/ModelStore.ts`
**Status**: `DONE`
**Commit**: 0084e65

**Change**:
- [X] Update HF model path construction to use `model.repo`
- [X] Implement backwards compatibility (check old path first)

**Code Guidance**:
Replace lines 729-733:
```typescript
// For HF models, use author/repo/model structure with backwards compatibility
if (model.origin === ModelOrigin.HF) {
  const author = model.author || 'unknown';
  const repo = model.repo || 'unknown';

  // Old path structure (for backwards compatibility)
  const oldPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${model.filename}`;

  // New path structure includes repository name
  const newPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${repo}/${model.filename}`;

  // Check if file exists at old path (backwards compatibility)
  // This handles: existing downloads, models after reset, models after app update
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old HF model path:', err);
  }

  // Otherwise use new path
  return newPath;
}
```

**Pattern Reference**: See `src/store/ModelStore.ts:710-727` for preset models backwards compatibility pattern

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
yarn test --findRelatedTests src/store/ModelStore.ts
```

### Step 5: Update Swift parseModelPath() for HF models
**Files**: `ios/PocketPal/AppIntents/PalDataProvider.swift`
**Status**: `DONE`
**Commit**: 9a669fb

**Change**:
- [X] Extract `repo` from dict for HF models
- [X] Implement backwards compatibility (matching TypeScript logic)

**Code Guidance**:
Replace lines 219-224:
```swift
// For HF models, use author/repo/model structure with backwards compatibility
if origin == "hf" {
    let author = dict["author"] as? String ?? "unknown"
    let repo = dict["repo"] as? String ?? "unknown"

    // Old path structure (for backwards compatibility)
    let oldPath = documentsPath.appendingPathComponent("models/hf/\(author)/\(filename)").path

    // New path structure includes repository name
    let newPath = documentsPath.appendingPathComponent("models/hf/\(author)/\(repo)/\(filename)").path

    // Check if file exists at old path (backwards compatibility)
    if fileManager.fileExists(atPath: oldPath) {
        print("[PalDataProvider] Found HF model at old path: \(oldPath)")
        return oldPath
    }

    // Otherwise use new path
    print("[PalDataProvider] Using new HF model path: \(newPath)")
    return newPath
}
```

**Pattern Reference**: See `ios/PocketPal/AppIntents/PalDataProvider.swift:202-216` for preset models Swift implementation

**Verification**:
```bash
cd "${WORKTREE_PATH}"
# Swift compilation verified during iOS build in review phase
```

---

## ITERATION 2 STEPS (NEW)

### Step 6: Update getModelFullPath() for PRESET models
**Files**: `src/store/ModelStore.ts`
**Status**: `PENDING`
**Commit**: TBD

**Change**:
- [ ] Update PRESET model path construction to use `model.repo`
- [ ] Implement backwards compatibility (check BOTH old paths first)

**Code Guidance**:
Replace lines 712-727:
```typescript
// For preset models, check both old and new paths
if (model.origin === ModelOrigin.PRESET) {
  const author = model.author || 'unknown';
  const repo = model.repo || 'unknown';
  
  // Very old path (deprecated, for backwards compatibility)
  const veryOldPath = `${RNFS.DocumentDirectoryPath}/${model.filename}`;
  
  // Old path (deprecated, for backwards compatibility)
  const oldPath = `${RNFS.DocumentDirectoryPath}/models/preset/${author}/${model.filename}`;
  
  // New path structure includes repository name
  const newPath = `${RNFS.DocumentDirectoryPath}/models/preset/${author}/${repo}/${model.filename}`;

  // Check if file exists at very old path first (for backwards compatibility)
  try {
    if (await RNFS.exists(veryOldPath)) {
      return veryOldPath;
    }
  } catch (err) {
    console.log('Error checking very old preset path:', err);
  }

  // Check if file exists at old path (for backwards compatibility)
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old preset path:', err);
  }

  // Otherwise use new path
  return newPath;
}
```

**Pattern Reference**: Follow the same pattern as HF models (Step 4), but with TWO old path checks

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
yarn test --findRelatedTests src/store/ModelStore.ts
```

### Step 7: Update Swift parseModelPath() for PRESET models
**Files**: `ios/PocketPal/AppIntents/PalDataProvider.swift`
**Status**: `PENDING`
**Commit**: TBD

**Change**:
- [ ] Extract `repo` from dict for PRESET models
- [ ] Implement backwards compatibility (matching TypeScript logic - check BOTH old paths)

**Code Guidance**:
Replace lines 202-216:
```swift
// For preset models, check both old and new paths
if origin == "preset" {
    let author = dict["author"] as? String ?? "unknown"
    let repo = dict["repo"] as? String ?? "unknown"
    
    // Very old path (deprecated, for backwards compatibility)
    let veryOldPath = documentsPath.appendingPathComponent(filename).path
    
    // Old path (deprecated, for backwards compatibility)
    let oldPath = documentsPath.appendingPathComponent("models/preset/\(author)/\(filename)").path
    
    // New path structure includes repository name
    let newPath = documentsPath.appendingPathComponent("models/preset/\(author)/\(repo)/\(filename)").path
    
    // Check if file exists at very old path first (for backwards compatibility)
    if fileManager.fileExists(atPath: veryOldPath) {
        print("[PalDataProvider] Found preset model at very old path: \(veryOldPath)")
        return veryOldPath
    }
    
    // Check if file exists at old path (for backwards compatibility)
    if fileManager.fileExists(atPath: oldPath) {
        print("[PalDataProvider] Found preset model at old path: \(oldPath)")
        return oldPath
    }
    
    // Otherwise use new path
    print("[PalDataProvider] Using new preset model path: \(newPath)")
    return newPath
}
```

**Pattern Reference**: Mirror the TypeScript implementation exactly (Step 6)

**Verification**:
```bash
cd "${WORKTREE_PATH}"
# Swift compilation verified during iOS build in review phase
```

### Step 8: Add tests for preset paths with repo
**Files**: `src/store/__tests__/ModelStore.test.ts`
**Status**: `PENDING`
**Commit**: TBD

**Change**:
- [ ] Add tests for new preset path with repo field
- [ ] Add tests for backwards compatibility with very old path
- [ ] Add tests for backwards compatibility with old path
- [ ] Add tests for fallback to 'unknown' if repo missing
- [ ] Add tests for error handling when checking old paths

**Code Guidance**:
Add these tests after the existing preset model tests (around line 1483):
```typescript
describe('getModelFullPath - PRESET models with repo field', () => {
  it('should construct new path with repo for PRESET model', async () => {
    const presetModel = {
      origin: ModelOrigin.PRESET,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock both old paths don't exist
    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(presetModel as any);
    expect(path).toContain('/models/preset/test-author/test-repo/model.gguf');
  });

  it('should use very old path if file exists there for PRESET model (backwards compatibility)', async () => {
    const presetModel = {
      origin: ModelOrigin.PRESET,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock very old path exists (first call returns true)
    (RNFS.exists as jest.Mock).mockResolvedValue(true);

    const path = await modelStore.getModelFullPath(presetModel as any);
    expect(path).toContain('/model.gguf');
    expect(path).not.toContain('/models/preset/');
    expect(path).not.toContain('/test-repo/');
  });

  it('should use old path if very old path does not exist but old path exists for PRESET model', async () => {
    const presetModel = {
      origin: ModelOrigin.PRESET,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock very old path doesn't exist (first call), but old path exists (second call)
    (RNFS.exists as jest.Mock)
      .mockResolvedValueOnce(false)  // very old path
      .mockResolvedValueOnce(true);  // old path

    const path = await modelStore.getModelFullPath(presetModel as any);
    expect(path).toContain('/models/preset/test-author/model.gguf');
    expect(path).not.toContain('/test-repo/');
  });

  it('should fallback to unknown if repo field missing for PRESET model', async () => {
    const presetModel = {
      origin: ModelOrigin.PRESET,
      filename: 'model.gguf',
      author: 'test-author',
      // repo field intentionally missing
    };

    // Mock both old paths don't exist
    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(presetModel as any);
    expect(path).toContain('/models/preset/test-author/unknown/model.gguf');
  });

  it('should handle error when checking very old path for PRESET model', async () => {
    const presetModel = {
      origin: ModelOrigin.PRESET,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock RNFS.exists to throw error for very old path, then return false for old path
    (RNFS.exists as jest.Mock)
      .mockRejectedValueOnce(new Error('File system error'))  // very old path
      .mockResolvedValueOnce(false);  // old path

    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();

    const path = await modelStore.getModelFullPath(presetModel as any);
    // Should still check old path and eventually return new path
    expect(path).toContain('/models/preset/test-author/test-repo/model.gguf');
    expect(consoleLogSpy).toHaveBeenCalledWith(
      'Error checking very old preset path:',
      expect.any(Error),
    );

    consoleLogSpy.mockRestore();
  });

  it('should handle error when checking old path for PRESET model', async () => {
    const presetModel = {
      origin: ModelOrigin.PRESET,
      filename: 'model.gguf',
      author: 'test-author',
      repo: 'test-repo',
    };

    // Mock very old path doesn't exist, old path throws error
    (RNFS.exists as jest.Mock)
      .mockResolvedValueOnce(false)  // very old path
      .mockRejectedValueOnce(new Error('File system error'));  // old path

    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();

    const path = await modelStore.getModelFullPath(presetModel as any);
    // Should still return new path despite error
    expect(path).toContain('/models/preset/test-author/test-repo/model.gguf');
    expect(consoleLogSpy).toHaveBeenCalledWith(
      'Error checking old preset path:',
      expect.any(Error),
    );

    consoleLogSpy.mockRestore();
  });
});
```

**Pattern Reference**: Follow the same test pattern as HF models (lines 1511-1581), adapted for preset models with TWO old path checks

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn test --findRelatedTests src/store/ModelStore.ts
```

---

## Test Requirements

### Unit Tests
| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| New HF path includes repository name | `ModelStore.test.ts` | MUST | DONE |
| Backwards compat - old path preferred if exists (HF) | `ModelStore.test.ts` | MUST | DONE |
| Uses model.repo field for path (HF) | `ModelStore.test.ts` | MUST | DONE |
| Fallback to 'unknown' if repo missing (HF) | `ModelStore.test.ts` | MUST | DONE |
| Error handling when checking old path (HF) | `ModelStore.test.ts` | SHOULD | DONE |
| hfAsModel sets repo correctly | `utils.test.ts` | MUST | DONE |
| **New PRESET path includes repository name** | `ModelStore.test.ts` | MUST | PENDING |
| **Backwards compat - very old path preferred (PRESET)** | `ModelStore.test.ts` | MUST | PENDING |
| **Backwards compat - old path preferred (PRESET)** | `ModelStore.test.ts` | MUST | PENDING |
| **Fallback to 'unknown' if repo missing (PRESET)** | `ModelStore.test.ts` | MUST | PENDING |
| **Error handling when checking very old path (PRESET)** | `ModelStore.test.ts` | SHOULD | PENDING |
| **Error handling when checking old path (PRESET)** | `ModelStore.test.ts` | SHOULD | PENDING |

### Manual Testing
- [X] Download a new HF model and verify it goes to new path structure
- [X] Verify existing downloaded HF models still work (old path)
- [ ] Download a new PRESET model and verify it goes to new path structure
- [ ] Verify existing downloaded PRESET models still work (very old or old path)
- [ ] Test reset functionality - model should still work after reset
- [ ] Check that multimodal models (with projection models) work correctly

---

## Coding Standards

### Testing Infrastructure (CRITICAL)
```
# Read these BEFORE writing tests:
/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639/jest/setup.ts      # Global mocks
/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639/jest/test-utils.tsx # Custom render
/Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639/__mocks__/stores/  # Mock stores

# DO NOT mock stores inline - they're globally mocked
# Use runInAction() for MobX state changes
# Import render from jest/test-utils, NOT @testing-library/react-native
```

### Patterns to Follow
- **State**: Use MobX `@observable`, `@action`, `@computed`
- **Async Actions**: Use `runInAction()` for state updates after async operations
- **Error Handling**: Use try-catch, log errors, gracefully fallback
- **Testing**: Follow existing test patterns in ModelStore.test.ts

### Commit Format (enforced by commitlint)
```
type(scope): subject
```

**Rules**:
- Header max: 100 chars total
- Types allowed: `feat`, `fix`, `docs`, `chore` (only these 4)
- No Co-Authored-By needed
- Keep it short and clear

**Examples**:
```
fix(model): add repo to preset model paths for consistency
fix(ios): update Swift parseModelPath for preset repo field
fix(test): add tests for preset model paths with repo
```

### Naming Conventions
- Variables: camelCase (`repo`, `oldPath`, `newPath`, `veryOldPath`)
- Constants: UPPER_SNAKE_CASE if truly constant
- Functions: camelCase (`getModelFullPath`)

---

## Reference Code

### Pattern Example: HF Models with Repo (Completed in Iteration 1)
**File**: `src/store/ModelStore.ts`
**Lines**: 730-750
```typescript
// For HF models, use author/repo/model structure with backwards compatibility
if (model.origin === ModelOrigin.HF) {
  const author = model.author || 'unknown';
  const repo = model.repo || 'unknown';

  // Old path structure (for backwards compatibility)
  const oldPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${model.filename}`;

  // New path structure includes repository name
  const newPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${repo}/${model.filename}`;

  // Check if file exists at old path (backwards compatibility)
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old HF model path:', err);
  }

  // Otherwise use new path
  return newPath;
}
```

### Pattern Example: Preset Models Current Implementation
**File**: `src/store/ModelStore.ts`
**Lines**: 712-727
```typescript
// For preset models, check both old and new paths
if (model.origin === ModelOrigin.PRESET) {
  const author = model.author || 'unknown';
  const oldPath = `${RNFS.DocumentDirectoryPath}/${model.filename}`; // old path is deprecated
  const newPath = `${RNFS.DocumentDirectoryPath}/models/preset/${author}/${model.filename}`;

  // If the file exists in old path, use that (for backwards compatibility)
  try {
    if (await RNFS.exists(oldPath)) {
      return oldPath;
    }
  } catch (err) {
    console.log('Error checking old path:', err);
  }

  // Otherwise use new path
  return newPath;
}
```

### Pattern Example: mergeModelLists() Object.assign behavior
**File**: `src/store/ModelStore.ts`
**Lines**: 520-531
```typescript
// This merges any NEW fields from defaultModel into existing model
const {
  id, defaultChatTemplate, defaultStopWords, chatTemplate, stopWords,
  ...attributesToMerge
} = defaultModel;

Object.assign(existingModel, attributesToMerge);
// ^ This will add `repo` field to existing persisted models on version change
```

---

## Dependencies

### Blocked By
- None

### Blocks
- None

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| TypeScript and Swift implementations diverge | Medium | High | Add explicit comment in both files referencing each other, mirror logic exactly |
| Preset models missing `repo` field | Low | Medium | All presets already have `repo` field from Iteration 1 |
| Existing models become inaccessible | Low | High | Backwards compatibility checks ensure old paths work (3 paths for presets) |
| Reset breaks model access | Low | High | Backwards compat handles file location mismatch after reset |
| `mergeModelLists()` doesn't merge `repo` | Low | Medium | `Object.assign()` includes all fields not explicitly excluded |
| Error in one old path check breaks entire flow | Low | Medium | Each path check wrapped in separate try-catch |

---

## Open Questions

### For Human
- None

### Resolved
- **Q**: Should we parse `repo` from `model.id` or add explicit field?
- **A**: Add explicit `repo` field - cleaner, follows `author` pattern, set once during download/preset definition
- **Q**: Should preset models also use repo in path for consistency?
- **A**: Yes - decided in Iteration 2 for single pattern consistency

---

## Agent Reports

### Planner Report (Iteration 1)
```
Research completed on 2026-02-05T17:00:00Z

REVISION: Updated approach per human feedback

Original approach: Parse repo from model.id string
Revised approach: Add explicit `repo` field to Model type

Key Findings:
1. Preset models defined in defaultModels.ts with MODEL_LIST_VERSION tracking
2. resetModels() wipes and rebuilds from defaultModels via mergeModelLists()
3. mergeModelLists() uses Object.assign() - will auto-merge new `repo` field
4. Edge case: After reset/update, model has `repo` but file at old path
5. Solution: Always check old path first (backwards compatibility pattern)

Files affected: 6 files
- types.ts (add repo field)
- defaultModels.ts (add repo to presets, increment version)
- utils/index.ts (set repo in hfAsModel)
- ModelStore.ts (use model.repo in getModelFullPath)
- PalDataProvider.swift (use repo from dict)
- ModelStore.test.ts (tests)

Complexity justified by: Cross-platform sync + backwards compatibility + multiple edge cases
```

### Planner Report (Iteration 2)
```
Research completed on 2026-02-06T10:30:00Z

ITERATION 2: Add repo to preset model paths for consistency

Context:
- Iteration 1 completed: HF models now use repo in path
- Human testing revealed: preset models don't use repo in path
- Decision: Update preset paths for consistency (single pattern)

Key Findings:
1. Preset models already have `repo` field (added in Iteration 1)
2. Current preset paths: check 2 paths (very old, old)
3. New preset paths: check 3 paths (very old, old, new with repo)
4. TypeScript and Swift must mirror HF implementation exactly
5. Pattern: Check old paths first, use new path as fallback

Files affected: 3 files
- ModelStore.ts (update PRESET path logic)
- PalDataProvider.swift (update preset path logic)
- ModelStore.test.ts (add 6 new tests for preset paths)

Changes:
- Step 6: TypeScript preset paths with repo
- Step 7: Swift preset paths with repo
- Step 8: Tests for preset paths with backwards compat

Implementation follows HF pattern exactly, but with TWO old path checks instead of one.
```

### Implementation Report (Iteration 1)
```
Implementation completed on 2026-02-05T18:00:00Z

Environment:
- Task ID: TASK-20260205-1639
- Worktree: /Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639
- Branch: feature/TASK-20260205-1639

Status: COMPLETE

Changes Made:
| File | Change | Commit |
|------|--------|--------|
| src/utils/types.ts | Added repo?: string to Model interface | 670ccc9 |
| src/store/defaultModels.ts | Incremented MODEL_LIST_VERSION to 14, added repo to 10 preset models | 936363a |
| src/utils/index.ts | Extract repo from hfModel.id and set in hfAsModel() | f351c97 |
| src/store/ModelStore.ts | Updated getModelFullPath() with backwards compatibility | 0084e65 |
| src/store/__tests__/ModelStore.test.ts | Updated test expectations for new path structure | 0084e65 |
| ios/PocketPal/AppIntents/PalDataProvider.swift | Updated parseModelPath() with backwards compatibility | 9a669fb |

Deviations from Plan:
- Added 300ms wait in test for checkSpaceAndDownload async completion (fire-and-forget pattern)
- Updated test authToken expectation to 'mockPass' (from keychain mock)

Verification Results:
- Lint: PASS (16 pre-existing warnings, unrelated)
- TypeCheck: PASS
- Related Tests: PASS (all 1189 tests in ModelStore.test.ts)
- Coverage: 55.88% (below 60% threshold but unrelated to changes)

Notes for Tester:
- Focus on backwards compatibility testing
- Verify new HF downloads use new path structure
- Verify existing models at old paths still load
- Test mergeModelLists() adds repo field to persisted models
- Verify TypeScript and Swift produce identical paths
```

### Test Report (Iteration 1)
```
Test Report for TASK-20260205-1639
Testing completed on 2026-02-05

Environment:
- Task ID: TASK-20260205-1639
- Worktree: /Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639
- Branch: feature/TASK-20260205-1639

Tests Written:
1. ModelStore.test.ts (5 new tests for HF model path handling):
   - should construct new path with repo for HF model
   - should use old path if file exists there for HF model (backwards compatibility)
   - should fallback to unknown if repo field missing for HF model
   - should handle error when checking old path for HF model
   - (1 existing test updated for new path expectations)

2. utils.test.ts (4 new tests for hfAsModel function):
   - should extract and set repo from hfModel.id
   - should handle hfModel.id with different author/repo format
   - should handle hfModel.id with no slash (undefined repo)
   - should handle hfModel.id with single slash (undefined repo)

Test Results:
- Total: 153 tests (all in ModelStore + utils test suites)
- New tests: 9 tests
- Passed: 153 tests (100%)
- Failed: 0

Coverage Summary (ModelStore.ts):
- Statements: 72.5%
- Branches: 58.63%
- Functions: 72.69%
- Lines: 72.57%

Test Categories Validated:
✓ New HF path includes repository name
✓ Backwards compatibility - old path preferred if exists
✓ Uses model.repo field for path construction
✓ Fallback to 'unknown' if repo missing
✓ Error handling when checking old path
✓ hfAsModel sets repo correctly from hfModel.id

Notes for Reviewer:
- All acceptance criteria tests are passing
- Backwards compatibility is thoroughly tested
- Error handling is verified for file system failures
- hfAsModel correctly extracts repo from various ID formats
- No flaky tests observed across multiple runs
- Implementation follows existing test patterns exactly
```

### Review Report (Iteration 1)
```
[Filled by reviewer after review]
```

---

## Changelog

| Date | Agent/Human | Change |
|------|-------------|--------|
| 2026-02-05 | orchestrator | Created worktree and task |
| 2026-02-05 | planner | Initial story draft |
| 2026-02-05 | human | Requested revision: use explicit `repo` field instead of parsing |
| 2026-02-05 | planner | Revised story with `repo` field approach |
| 2026-02-05 | implementer | Completed Steps 1-5 for HF models |
| 2026-02-05 | tester | Added 9 tests, all passing |
| 2026-02-05 | reviewer | Created draft PR #559 |
| 2026-02-06 | human | Tested: preset models don't use repo in path - add for consistency |
| 2026-02-06 | human | Requested Iteration 2: add repo to preset paths |
| 2026-02-06 | planner | Revised story with Steps 6-8 for preset path changes |
| 2026-02-06 | implementer | Completed Steps 6-7 for preset model paths |
| 2026-02-06 | tester | Added 6 tests for preset paths |
| 2026-02-06 | reviewer | Approved iteration 2, updated PR #559 |
| 2026-02-06 | human | Identified edge case: existing HF models lack repo field |
| 2026-02-06 | human | Requested Iteration 3: infer repo from model.id |

---

## ITERATION 3 STEPS: Infer repo from model.id for existing HF models

### Research Findings (2026-02-06)

**Edge Case Identified:**
Existing HF models (downloaded or bookmarked before this update) won't have the `repo` field in their persisted model object. However, the `model.id` contains the repo information in the format `author/repo/filename`.

**Current Behavior:**
- Path construction uses: `const repo = model.repo || 'unknown';`
- Falls back to `'unknown'` if repo field is missing
- Backwards compat checks find file at old path successfully
- BUT: Using `'unknown'` is misleading when repo info IS available in model.id

**Model ID Structure:**
- HF model IDs: `"author/repo/filename"` (e.g., `"bartowski/gemma-2-2b-it-GGUF/model.gguf"`)
- Parsing pattern exists at line 2294: `model.id.split('/')` → `[author, repo, filename]`
- Same pattern used in `hfAsModel()` at lines 451-452

**Existing Patterns:**
1. `mergeModelLists()` (line 485): Called on version change, uses `Object.assign()` to merge fields
2. Defensive fallbacks already used: `model.author || 'unknown'` (lines 713, 749)
3. `getModelFullPath()` already has repo fallback: `model.repo || 'unknown'` (lines 714, 750)

**Recommended Approach: Option C (Belt and Suspenders)**

**Primary Fix**: Infer repo during `mergeModelLists()` for HF models
- Follows existing pattern: data normalization during migration
- Ensures ALL code using `model.repo` has correct data
- Cleaner separation of concerns

**Fallback**: Enhance defensive check in `getModelFullPath()` 
- Change from `model.repo || 'unknown'` to infer from model.id
- Handles edge cases where initialization might be skipped
- Belt-and-suspenders approach for safety

**Why This Approach:**
1. Primary fix is cleaner: corrects data at source
2. Fallback is safer: defensive programming
3. Follows existing codebase patterns
4. Create reusable utility function: `inferRepoFromModelId()`
5. Each location testable independently

---

### Step 9: Add utility function and update mergeModelLists()

**Files**: `src/utils/index.ts`, `src/store/ModelStore.ts`
**Status**: `DONE`
**Commit**: fff6154

**Change**:
- [x] Add `inferRepoFromModelId()` utility function
- [x] Update `mergeModelLists()` to infer repo for HF models if missing
- [x] Ensure preset models are not affected

**Code Guidance**:

Add to `src/utils/index.ts` (after `hfAsModel()` function, around line 497):
```typescript
/**
 * Infers the repository name from a HuggingFace model ID.
 * HF model IDs have format: "author/repo/filename"
 * 
 * @param modelId - The full model ID (e.g., "bartowski/gemma-2-2b-it-GGUF/model.gguf")
 * @returns The repository name, or undefined if not parseable
 * 
 * @example
 * inferRepoFromModelId("bartowski/gemma-2-2b-it-GGUF/model.gguf")
 * // Returns: "gemma-2-2b-it-GGUF"
 */
export function inferRepoFromModelId(modelId: string): string | undefined {
  const parts = modelId.split('/');
  // HF model IDs should have at least 3 parts: author/repo/filename
  return parts.length >= 3 ? parts[1] : undefined;
}
```

Update `src/store/ModelStore.ts` in `mergeModelLists()` function, add after line 572 (inside HF/LOCAL handling block):
```typescript
    // Handle HF and LOCAL models
    mergedModels.forEach(model => {
      if (
        model.origin === ModelOrigin.HF ||
        model.origin === ModelOrigin.LOCAL ||
        model.isLocal
      ) {
        // ... existing code for default settings (lines 550-570)

        // NEW: Infer repo from model.id if missing (for existing HF models)
        if (model.origin === ModelOrigin.HF && !model.repo) {
          const inferredRepo = inferRepoFromModelId(model.id);
          if (inferredRepo) {
            model.repo = inferredRepo;
            console.log(`[ModelStore] Inferred repo "${inferredRepo}" from model.id: ${model.id}`);
          }
        }
      }
    });
```

**Pattern Reference**: See lines 542-572 for existing HF/LOCAL model handling in `mergeModelLists()`

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
yarn test --findRelatedTests src/store/ModelStore.ts src/utils/index.ts
```

---

### Step 10: Enhance getModelFullPath() fallback (TypeScript and Swift)

**Files**: `src/store/ModelStore.ts`, `ios/PocketPal/AppIntents/PalDataProvider.swift`
**Status**: `DONE`
**Commit**: 8ac9d8e

**Change**:
- [x] Update TypeScript `getModelFullPath()` to infer repo from model.id as fallback
- [x] Update Swift `parseModelPath()` to infer repo from model ID as fallback
- [x] Maintain backwards compatibility

**Code Guidance (TypeScript)**:

Update `src/store/ModelStore.ts` lines 748-751:
```typescript
    // For HF models, use author/repo/model structure with backwards compatibility
    if (model.origin === ModelOrigin.HF) {
      const author = model.author || 'unknown';
      
      // Try to get repo from model, or infer from model.id, or fallback to 'unknown'
      let repo = model.repo;
      if (!repo) {
        repo = inferRepoFromModelId(model.id) || 'unknown';
      }

      // Old path structure (for backwards compatibility)
      const oldPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${model.filename}`;

      // New path structure includes repository name
      const newPath = `${RNFS.DocumentDirectoryPath}/models/hf/${author}/${repo}/${model.filename}`;

      // ... rest of backwards compat logic (unchanged)
    }
```

**Code Guidance (Swift)**:

Update `ios/PocketPal/AppIntents/PalDataProvider.swift` lines 234-252:

Add helper function before `parseModelPath()`:
```swift
    /// Infers repository name from HF model ID format: "author/repo/filename"
    private func inferRepoFromModelId(_ modelId: String) -> String? {
        let parts = modelId.components(separatedBy: "/")
        // HF model IDs should have at least 3 parts: author/repo/filename
        return parts.count >= 3 ? parts[1] : nil
    }
```

Update HF model path logic (replace lines 234-252):
```swift
        // For HF models, use author/repo/model structure with backwards compatibility
        if origin == "hf" {
            let author = dict["author"] as? String ?? "unknown"
            
            // Try to get repo from dict, or infer from model ID, or fallback to 'unknown'
            var repo = dict["repo"] as? String ?? "unknown"
            if repo == "unknown" {
                // Try to infer from model ID
                if let modelId = dict["id"] as? String,
                   let inferredRepo = inferRepoFromModelId(modelId) {
                    repo = inferredRepo
                    print("[PalDataProvider] Inferred repo '\(repo)' from model ID: \(modelId)")
                }
            }

            // Old path structure (for backwards compatibility)
            let oldPath = documentsPath.appendingPathComponent("models/hf/\(author)/\(filename)").path

            // New path structure includes repository name
            let newPath = documentsPath.appendingPathComponent("models/hf/\(author)/\(repo)/\(filename)").path

            // Check if file exists at old path (backwards compatibility)
            if fileManager.fileExists(atPath: oldPath) {
                print("[PalDataProvider] Found HF model at old path: \(oldPath)")
                return oldPath
            }

            // Otherwise use new path
            print("[PalDataProvider] Using new HF model path: \(newPath)")
            return newPath
        }
```

**Pattern Reference**: 
- TypeScript: Existing pattern at lines 748-767
- Swift: Existing pattern at lines 234-252

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn typecheck
yarn lint
yarn test --findRelatedTests src/store/ModelStore.ts
# Swift compilation verified during iOS build in review phase
```

---

### Step 11: Add tests for repo inference

**Files**: `src/utils/__tests__/index.test.ts`, `src/store/__tests__/ModelStore.test.ts`
**Status**: `PENDING`
**Commit**: TBD

**Change**:
- [ ] Add tests for `inferRepoFromModelId()` utility function
- [ ] Add tests for repo inference during `mergeModelLists()`
- [ ] Add tests for repo inference fallback in `getModelFullPath()`

**Code Guidance**:

Create or update `src/utils/__tests__/index.test.ts`:
```typescript
describe('inferRepoFromModelId', () => {
  it('should extract repo from valid HF model ID', () => {
    const modelId = 'bartowski/gemma-2-2b-it-GGUF/model.gguf';
    expect(inferRepoFromModelId(modelId)).toBe('gemma-2-2b-it-GGUF');
  });

  it('should handle model ID with special characters in repo', () => {
    const modelId = 'author/repo-name_v2.0/file.gguf';
    expect(inferRepoFromModelId(modelId)).toBe('repo-name_v2.0');
  });

  it('should return undefined for malformed ID (no slashes)', () => {
    const modelId = 'invalid-id';
    expect(inferRepoFromModelId(modelId)).toBeUndefined();
  });

  it('should return undefined for ID with only one slash', () => {
    const modelId = 'author/filename.gguf';
    expect(inferRepoFromModelId(modelId)).toBeUndefined();
  });

  it('should handle model ID with extra slashes', () => {
    const modelId = 'author/repo/subdir/file.gguf';
    expect(inferRepoFromModelId(modelId)).toBe('repo');
  });
});
```

Add to `src/store/__tests__/ModelStore.test.ts` (after existing HF model tests, around line 1580):
```typescript
describe('getModelFullPath - HF models with repo inference', () => {
  it('should infer repo from model.id when repo field is missing', async () => {
    const hfModel = {
      origin: ModelOrigin.HF,
      id: 'bartowski/gemma-2-2b-it-GGUF/model.gguf',
      filename: 'model.gguf',
      author: 'bartowski',
      // repo field intentionally missing (simulates existing model before update)
    };

    // Mock both old paths don't exist
    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(hfModel as any);
    // Should infer repo from model.id
    expect(path).toContain('/models/hf/bartowski/gemma-2-2b-it-GGUF/model.gguf');
  });

  it('should use explicit repo field over inferred value', async () => {
    const hfModel = {
      origin: ModelOrigin.HF,
      id: 'bartowski/gemma-2-2b-it-GGUF/model.gguf',
      filename: 'model.gguf',
      author: 'bartowski',
      repo: 'explicit-repo-name',
    };

    // Mock both old paths don't exist
    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(hfModel as any);
    // Should use explicit repo field
    expect(path).toContain('/models/hf/bartowski/explicit-repo-name/model.gguf');
  });

  it('should fallback to unknown if repo missing and cannot infer', async () => {
    const hfModel = {
      origin: ModelOrigin.HF,
      id: 'invalid-id', // Malformed ID - cannot infer repo
      filename: 'model.gguf',
      author: 'bartowski',
      // repo field intentionally missing
    };

    // Mock both old paths don't exist
    (RNFS.exists as jest.Mock).mockResolvedValue(false);

    const path = await modelStore.getModelFullPath(hfModel as any);
    // Should fallback to 'unknown'
    expect(path).toContain('/models/hf/bartowski/unknown/model.gguf');
  });
});

describe('mergeModelLists - repo inference for HF models', () => {
  it('should infer and set repo field for existing HF models', () => {
    // Set up store with existing HF model (no repo field)
    modelStore.models = [
      {
        id: 'test-author/test-repo/model.gguf',
        origin: ModelOrigin.HF,
        author: 'test-author',
        // repo field missing (simulates existing model before update)
        isDownloaded: true,
        hfModel: {id: 'test-author/test-repo'} as any,
      } as Model,
    ];

    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();

    modelStore.mergeModelLists();

    // Check repo was inferred and set
    expect(modelStore.models[0].repo).toBe('test-repo');
    expect(consoleLogSpy).toHaveBeenCalledWith(
      expect.stringContaining('Inferred repo "test-repo"'),
      expect.any(String),
    );

    consoleLogSpy.mockRestore();
  });

  it('should not override existing repo field', () => {
    // Set up store with HF model that already has repo field
    modelStore.models = [
      {
        id: 'test-author/inferred-repo/model.gguf',
        origin: ModelOrigin.HF,
        author: 'test-author',
        repo: 'existing-repo', // Already has repo field
        isDownloaded: true,
        hfModel: {id: 'test-author/inferred-repo'} as any,
      } as Model,
    ];

    modelStore.mergeModelLists();

    // Should keep existing repo field
    expect(modelStore.models[0].repo).toBe('existing-repo');
  });

  it('should handle HF models with malformed IDs gracefully', () => {
    modelStore.models = [
      {
        id: 'malformed-id',
        origin: ModelOrigin.HF,
        author: 'test-author',
        // repo field missing, ID is malformed
        isDownloaded: true,
        hfModel: {id: 'malformed'} as any,
      } as Model,
    ];

    // Should not throw error
    expect(() => modelStore.mergeModelLists()).not.toThrow();
    
    // Repo should remain undefined
    expect(modelStore.models[0].repo).toBeUndefined();
  });

  it('should not affect PRESET models', () => {
    modelStore.models = [
      {
        id: 'preset-model',
        origin: ModelOrigin.PRESET,
        author: 'preset-author',
        // repo field missing
        isDownloaded: true,
      } as Model,
    ];

    modelStore.mergeModelLists();

    // Preset models should not be affected by HF repo inference
    expect(modelStore.models[0].repo).toBeUndefined();
  });
});
```

**Pattern Reference**: Follow existing test patterns at lines 1511-1581 (HF model tests) and utils.test.ts patterns

**Verification**:
```bash
cd "${WORKTREE_PATH}"
yarn test --findRelatedTests src/utils/index.ts src/store/ModelStore.ts
```

---

## Updated Test Requirements (Iteration 3)

Add to existing test requirements table:

| Test Case | File | Priority | Status |
|-----------|------|----------|--------|
| inferRepoFromModelId extracts repo correctly | `utils/index.test.ts` | MUST | PENDING |
| inferRepoFromModelId handles malformed IDs | `utils/index.test.ts` | MUST | PENDING |
| getModelFullPath infers repo from model.id when missing | `ModelStore.test.ts` | MUST | PENDING |
| getModelFullPath prefers explicit repo over inferred | `ModelStore.test.ts` | MUST | PENDING |
| mergeModelLists infers repo for existing HF models | `ModelStore.test.ts` | MUST | PENDING |
| mergeModelLists does not override existing repo | `ModelStore.test.ts` | MUST | PENDING |
| mergeModelLists handles malformed IDs gracefully | `ModelStore.test.ts` | SHOULD | PENDING |
| mergeModelLists does not affect PRESET models | `ModelStore.test.ts` | SHOULD | PENDING |

---

## Updated Acceptance Criteria (Iteration 3)

Add to existing acceptance criteria:

- [ ] `inferRepoFromModelId()` utility function extracts repo from HF model IDs
- [ ] `mergeModelLists()` infers and sets repo for existing HF models with missing repo field
- [ ] `mergeModelLists()` does not override existing repo fields
- [ ] `getModelFullPath()` (TypeScript) infers repo from model.id as fallback
- [ ] `parseModelPath()` (Swift) infers repo from model ID as fallback
- [ ] Existing repo fields take precedence over inferred values
- [ ] Malformed model IDs fallback to 'unknown' gracefully
- [ ] PRESET models are not affected by HF repo inference
- [ ] All new tests pass
- [ ] Coverage >= 60%

---

## Risk Analysis for Iteration 3

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Inference fails for non-standard model IDs | Low | Medium | Fallback to 'unknown', backwards compat still works |
| mergeModelLists called multiple times | Low | Low | Inference is idempotent (only sets if missing) |
| Swift and TypeScript implementations diverge | Low | Medium | Mirror logic exactly, add comments referencing each other |
| Affects non-HF models | Low | High | Explicitly check `model.origin === ModelOrigin.HF` |
| Performance impact from parsing model.id | Very Low | Low | String split is O(n), happens once per model at startup |

---

## Implementation Report - Iteration 3

### Environment
- **Task ID**: TASK-20260205-1639
- **Worktree**: /Users/aghorbani/codes/pocketpal-dev-team/worktrees/TASK-20260205-1639
- **Branch**: feature/TASK-20260205-1639

### Story
TASK-20260205-1639: Fix HuggingFace Model File Storage Paths - Iteration 3

### Status
partial - Steps 9-10 complete, Step 11 (tests) remains

### Changes Made

| File | Change | Commit |
|------|--------|--------|
| `src/utils/index.ts` | Added `inferRepoFromModelId()` utility function | fff6154 |
| `src/store/ModelStore.ts` | Import `inferRepoFromModelId`, update `mergeModelLists()` to infer repo for HF models | fff6154 |
| `src/utils/index.ts` | Added null guard to `inferRepoFromModelId()` | 8ac9d8e |
| `src/store/ModelStore.ts` | Enhanced `getModelFullPath()` HF section to infer repo as fallback | 8ac9d8e |
| `ios/PocketPal/AppIntents/PalDataProvider.swift` | Added Swift `inferRepoFromModelId()` helper function | 8ac9d8e |
| `ios/PocketPal/AppIntents/PalDataProvider.swift` | Updated `parseModelPath()` to infer repo for HF models | 8ac9d8e |

### Implementation Details

#### Step 9: Utility Function and mergeModelLists()
- Created `inferRepoFromModelId()` in `src/utils/index.ts`
  - Parses HF model ID format: `author/repo/filename`
  - Returns repo (2nd part) or undefined if not parseable
  - Includes null/undefined guard
- Updated `mergeModelLists()` in ModelStore.ts
  - Added import for `inferRepoFromModelId`
  - After line 570, added inference logic for HF models
  - Only sets repo if missing (idempotent)
  - Logs when inference happens for debugging
  - Does NOT affect preset models (check is `origin === ModelOrigin.HF`)

#### Step 10: Enhanced Path Fallback
- TypeScript (`getModelFullPath()`):
  - Changed from `model.repo || 'unknown'`
  - To: try `model.repo`, then infer from `model.id`, then fallback to 'unknown'
  - Maintains backwards compatibility with old paths
- Swift (`PalDataProvider.swift`):
  - Added `inferRepoFromModelId()` helper (mirrors TypeScript version)
  - Updated `parseModelPath()` HF section
  - Tries dict["repo"], then infers from model ID, then fallback to 'unknown'
  - Added logging when inference happens

### Deviations from Plan
None - implementation followed the plan exactly.

### Verification Results
- **Lint**: PASS (16 pre-existing warnings, no new issues)
- **TypeCheck**: PASS
- **Related Tests**: 1 FAIL (pre-existing, unrelated to changes)
  - Failure: `ModelStore › projection model deletion › should automatically cleanup orphaned projection model when LLM is deleted`
  - This test was failing before my changes (tests projection model cleanup, not repo field)
  - My changes added null guard that fixed 2 new test failures
- **Pod Install**: N/A (NATIVE_CHANGES=NO)
- **iOS Build**: N/A (will be verified in review phase)
- **Android Build**: N/A (will be verified in review phase)

### Notes for Tester
1. **Test Coverage Needed**:
   - Unit tests for `inferRepoFromModelId()` utility function
   - Integration tests for repo inference in `mergeModelLists()`
   - Integration tests for repo inference fallback in `getModelFullPath()`

2. **Test Scenarios**:
   - Valid HF model ID: `"author/repo/file.gguf"` → should extract "repo"
   - Malformed IDs: `"invalid"`, `"author/file"` → should return undefined
   - Model IDs with extra slashes: `"author/repo/subdir/file"` → should return "repo"
   - Null/undefined model ID → should return undefined
   - Preset models should NOT be affected
   - HF models without repo should get it inferred on startup
   - HF models with existing repo should keep it (idempotent)

3. **Focus Areas**:
   - The utility function is used in both startup (mergeModelLists) and runtime (getModelFullPath)
   - Both paths should be tested
   - Verify preset models are not affected by HF inference logic

### Blockers
None - implementation complete for Steps 9-10. Ready for tester to add tests (Step 11).

